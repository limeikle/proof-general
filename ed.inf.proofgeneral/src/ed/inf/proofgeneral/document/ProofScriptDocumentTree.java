/*
 *  This file is part of Proof General Eclipse
 *
 *  Created on Aug 7, 2007 by da
 *
 *  Copyright (C) University of Edinburgh and contributing authors.
 *    
 */

package ed.inf.proofgeneral.document;

import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

import org.dom4j.Element;
import org.dom4j.VisitorSupport;
import org.eclipse.core.runtime.AssertionFailedException;
import org.eclipse.jface.text.BadLocationException;
import org.eclipse.jface.text.DocumentEvent;
import org.eclipse.jface.text.Position;
import org.eclipse.jface.text.TypedPosition;

import ed.inf.proofgeneral.NotNull;
import ed.inf.proofgeneral.ProofGeneralPlugin;
import ed.inf.proofgeneral.document.ProofScriptDocument.ScriptingQueueState;
import ed.inf.proofgeneral.sessionmanager.PGIPSyntax;
import ed.inf.utils.datastruct.StringManipulation;
import ed.inf.utils.datastruct.TreeWalker;
import ed.inf.utils.datastruct.TreeWalker.Fn;
import ed.inf.utils.datastruct.TreeWalker.Tree;

/**
 * This class implements the model for the correctly parsed portion of proof scripts
 * and script management operations on it.
 *  
 * Script documents have an XML tree shadow which is generated by parsing the
 * PGIP markup given by the prover. The parsing operations keep this consistent
 * with the file contents, up to the parse offset. The PGIP markup has a flat
 * structure (no nested elements), but our tree shadow introduces containers
 * which correspond to visually and conceptually nested items in the document.
 * The conceptual nesting is generated by PGIP open elements and is used for
 * document-based undo using the PGIP model. The visual nesting is used for the
 * outline view. 
 * 
 * @author Daniel Winterstein - initial version
 * @author David Aspinall - new script management code, cleanups
 */
public class ProofScriptDocumentTree {

	@NotNull
	private final ProofScriptDocument doc;

	/**
     * The root of the parse tree.  The parse tree must only contains DocElement nodes.   
     */
	// We're reusing dom4j trees here but they are a bit general for what we want, and
	// lead to confusion over whether we're retaining the XML representation or not.
	// TODO: later refactoring should simplify this by using our own tree type and
	// just using positions from the document, not duplicating text, which would be
	// much more efficient.
    protected final ContainerElement fRootElement; 

	/** The open element is the position where we're currently adding to the parse tree.
	 * It is used by the parsing code. */
    // TODO: later refactoring should move this into the parser code, or (better) move the linkParse
    // portion of the parser code here.
	ContainerElement fOpenElement;

	
	/** The position of the region which is successfully parsed.  If none of the
	 * document is parsed, this has zero length. */
	private final ScriptManagementPosition fParsedRegion = new ScriptManagementPosition("ParsedRegion",0,0);
	

	/**
	 * Sets how much of the document has been parsed, and broadcasts the change.
	 * The offset is given as the position of the last character parsed.
	 * @param newOffset the new offset value.
	 * TODO:setParseOffset parse methods internal to document should do this directly
	 */
	public void setParseOffset(int newOffset) {
		int oldOffset = fParsedRegion.getLength()-1;
		fParsedRegion.setLength(newOffset+1);
		fParsedRegion.setOffset(0); // [ shouldn't be needed ]
		// NB: maybe broadcast to outline but nowhere else is needed really?????
		doc.processOffset(oldOffset, newOffset,false);
	}
	

	/**
	 * Return the offset of the last parsed character.
	 * If none of the document has been parsed yet, this is -1.
	 * @return the parse offset
	 */
	public int getParseOffset() {
		return fParsedRegion.getLength()-1;
	}
	
	
	public ProofScriptDocumentTree(ProofScriptDocument doc) {
		assert doc != null : "Must have a document";
		this.doc = doc;
		fRootElement = new ContainerElement(PGIPSyntax.ROOT_CONTAINER, doc, PGIPSyntax.OPENFILE);
		fRootElement.setPosition(new TypedPosition(0,0,"ROOT"));
		fOpenElement = fRootElement;
	}
	
	/**
     * Reset the positions of the parsed region and root element
     * and discard the parse tree.
     */
    public void reset() {
    	fParsedRegion.setOffset(0);
		fParsedRegion.setLength(0);
		fRootElement.getPosition().setOffset(0);
		setOpenElement(fRootElement);
		deleteParseTreeElements();
    }
    
	
	/**
	 * Set the document's 'open element',
	 * which is the container element where newly parsed doc elements are placed.
	 * The given container element is flagged as being open.
	 * @param de
	 */
	public void setOpenElement(ContainerElement de) {
		//        assert de.getParent() == fOpenElement : "Attempt to set "+de.asXML()+
		//        " as the open element when it is NOT a child of current open element "+fOpenElement.getText();
		fOpenElement = de;
		de.setOpen(true);  // FIXME: probably not needed because we never read open flag
	}

	/**
	 * Close the current open element, replacing it with its parent.
	 * If the open element is the root element, this has no effect.
	 */
	public void closeOpenElement() {
		if (fOpenElement == fRootElement) {
		   return;
		}
		fOpenElement.setOpen(false); // FIXME: probably not needed
		if (fOpenElement.getParent()!=null) {
			setOpenElement((ContainerElement)fOpenElement.getParent());
		}
	}
	
	
	/**
	 * Return the last element which ends before the given offset,
	 * discarding the parsed elements in the tree which appear afterwards. 
	 * @param feo where 0 <= feo <= document.getLength();
	 * @return the last element before feo; the root element or null if
	 * we hit that first.
	 */
	private DocElement deleteDocElementsAfter(final int feo) {
		if (feo == 0) {
			// short cut in case we're deleting everything
			deleteParseTreeElements();
			return fRootElement;
		}
		Fn fn = new Fn() {
			public Object apply(Tree node) {
				DocElement e = (DocElement) node; //BC ??
				// if we reach a container, it means all its contents have failed the test
				if (e instanceof ContainerElement) {
					assert e.elements().size()==0 : "Non-empty container during deletion";
					if (e==fRootElement) {
						// If we hit the root, make sure that it has empty length now
						e.getPosition().setLength(0);
						return e;
					} 
					// otherwise, remove the container
					e.delete();
					return null;
				}
				//best to ensure there is non-whitespace after command and _before_ the edit,
				//in case user is extending a previous command ("A B" and "A B C" both valid);
				//(also keep if it's locked!)
				//NB: many comments about the evolution of this strategy are in CVS for 7 Oct 07
				boolean keep = e.getEndOffset() <= doc.getLockOffset();
				if (!keep) {
					int i = e.getEndOffset()+1;
					try {
	                    while (i<feo && Character.isWhitespace(doc.getChar(i)))
	                    	i++;
	                    if (i<feo) keep=true;
                    } catch (BadLocationException e1) {
	                    //shouldn't happen, feo should be in doc
	                    e1.printStackTrace();
                    }					
				}
				if (keep) {
					//check containers are okay (extra check for trac 124)
					//and also clean up trailing whitespace
					DocElement de = e; 
					while (de.getParent() instanceof DocElement) {
						de = (DocElement) de.getParent();
						if (de.getEndOffset() != e.getEndOffset()) {
							int fixedLen = e.getStartOffset() + e.getPosition().getLength() - de.getStartOffset();
							String msg = "fixing parent container length, from ["+									
									de.getPosition().offset+"+="+de.getPosition().length+"] to " +
									"len "+fixedLen;
							try {
								if (de.getEndOffset() < e.getEndOffset()) {
									//shouldn't happen
									System.out.println("ERROR in ProofScriptDocumentTree.deleteDocEltsAfter: "+msg);
								} else if (doc.getText(new Position(e.getEndOffset()+1, de.getEndOffset() - e.getEndOffset())).trim().length()==0) {
									//TODO whitespace handling in parse is not particularly elegant; we have some parsed objects of size zero for whitespace,
									//some trailing whitespace included in other parses, and some whitespace not in any parsed objects
									//for now, seems wise to remove trailing whitespace, no need for a message
//									System.out.println("trailing whitespace, "+msg);
								} else {
									//shouldn't happen
									System.out.println("ERROR in ProofScriptDocumentTree.deleteDocEltsAfter: "+msg);								
								}
							} catch (BadLocationException exc) {
								//could this happen?
								System.out.println("ERROR in ProofScriptDocumentTree.deleteDocEltsAfter: outer container fell of the edge, "+msg);
							}
							de.getPosition().setLength(fixedLen);
						}
						if (de.getStartOffset() > e.getStartOffset()) {
							System.out.println("ERROR in ProofScriptDocumentTree.deleteDocEltsAfter: fixing parent container start, from ["+
									de.getPosition().offset+"+="+de.getPosition().length+"] to " +
									"start "+e.getStartOffset());
							de.getPosition().setOffset(e.getPosition().offset);
						}
					}
					return e;
				}
				e.delete();
				return null;
			}
		};
		return (DocElement) TreeWalker.reverseTreeWalk(fRootElement,fn);
	}
	
	/**
	 * Delete all the elements in the parse tree, leaving it empty.
	 */
	private void deleteParseTreeElements() {
		// First, we delete the positions for all the elements
		fRootElement.accept(new VisitorSupport() {
			@Override
            public void visit(Element node) {
				if (node instanceof DocElement) {
					((DocElement) node).deletePosition();
				}
			}
		});
		// Now make the tree empty
		fRootElement.setContent(null);
	}
	

	/**
	 * Throws away unreliable parse information for all positions at or after 
	 * the given offset, if there is any information.
	 * @param editOffset the position of an edit; must lie within the document
	 */
	// ENSURES: parseOffset < editOffset
	public void setParseRegionForEditAtOffset(int editOffset) {		
		/* new strategy requires non-whitespace between the current edit and the last kept parse;
		 * this is in case user is making an edit which is a continuation of the previous command,
		 * which is sometimes possible at the end.
		 * 
		 * it isn't foolproof -- "A B" and "A B C D" might be valid,
		 * but "A B C" not, so "A B C", parse, then add D, won't reparse A B;
		 * better way is to keep a "buffer zone" of one unchanged parsed command
		 * after the real parse offset and before the current edit.  (is this sufficient?)
		 * (is a lot of work ... alternatively parse on each edit, but that's expensive).
		 * TODO fix ambiguous parse as described above 
		 * 
		 * however note that if the document is locked up to the parse offset,
		 * then we don't want to reparse it!  changed in deleteDocElementsAfter.
		 * 
		 * NB +1 is needed because parse offset is index of last char
		 */
		int firstThingAfterLastParse = getParseOffset()+1;
		try {
	        while (firstThingAfterLastParse<editOffset && 
	        		Character.isWhitespace(doc.getChar(firstThingAfterLastParse)))
	        	firstThingAfterLastParse++;
        } catch (BadLocationException e) {
        	//shouldn't happen, as editOffset is in document
	        e.printStackTrace();
        }			
        if (firstThingAfterLastParse<editOffset) {			
			// No need to fix elements, but should remove markers from here til end
			ProofScriptMarkers.cleanMarkers(doc,getParseOffset()+1,doc.getLength()-1);
			return;
		}

		DocElement result = deleteDocElementsAfter(editOffset);
		
		int newParseOffset = getParseOffset();
		if (result==fRootElement) {
			setOpenElement(fRootElement);
			newParseOffset = -1;
		} else if (result != null) {
			ContainerElement ce = openContainer(result);
			setOpenElement(ce);
			newParseOffset = ce.getEndOffset();
		}
		// assert: newParseOffset <= getParseOffset()  FAILS OFTEN
		if (newParseOffset > getParseOffset()) {
			if (ProofGeneralPlugin.debug(this)) {
				System.err.println("Error in moving parse offset: attempt to move it forward to " + newParseOffset);
			}
			newParseOffset = -1; // fall back due to bug: parse whole doc
			// NB: there is a worse bug than this!! Sometimes we seem to parse old doc
			// contents, not new contents at all!  Is this because of use of secondary
			// thread to parse document?  Correct way is probably to launch parse job
			// from main thread, with cache of doc contents.  If contents changes when 
			// parse arrives, we don't update the model.  Can do Java-style weak sync 
			// check maybe, by modification count.
		}
		if (newParseOffset < getParseOffset()) {
			int parseChangeLength = doc.getLength()-newParseOffset-1;
			ProofScriptMarkers.cleanMarkers(doc,newParseOffset+1,parseChangeLength);
			setParseOffset(newParseOffset); // NB: partition change broadcast not needed?
			try {
				fireParseTreeChangedEvent(newParseOffset+1,parseChangeLength);
			} catch (BadLocationException ex) {
				//TODO fix this one happens sometimes on doc switch?
				System.err.println("ProofScriptDocument.setEditOffset tried to fire changed event with "
						+(newParseOffset+1)+" and "+parseChangeLength);
				ex.printStackTrace();
			} catch (Exception ex) {
				System.err.print("Error firing ParseTreeChange event with "+
						+(newParseOffset+1)+" and "+parseChangeLength);
				ex.printStackTrace();
			}
		}
	}

	/**
	 * If the parse tree has been changed, fire an event
	 */
	public void fireParseTreeChangedEvent(int offset, int length) throws BadLocationException {
		// FIXME da:
		// Negative lengths can come in here... after ordinary editing
		// (edit in file -> PSD.replace -> PSD.setEditOffset -> here.  Why fire a dummy change on edit offset, anyway?)
		if (length > 0) {
			String text = doc.get(offset,length); // FIXME: was super.get
			DocumentEvent e1 = new ScriptManagementDocumentEvent.ParseChangeEvent(doc,offset,length,text);
			try {
				doc.ourDoFireDocumentChanged(e1);
				// ah: i was getting concurrent modification errors to jface text undo history;
				// added a Display.asyncExec to the "ourDoFire" call -- seems like that should be right;
				// but maybe a syncExec is needed (but could it cause deadlocks?)
			} catch (AssertionFailedException a) {
				// da: allow these to be seen again, I'm trying to fix them by fixing calls to
				// this method.
				a.printStackTrace();
			}
		}
	}
	
	/**
	 * Returns the open container that subsequent elements should use
	 * FIXME: we should refactor the code here and in Parser.linkElement
	 * to have nodeShouldClosePreviousOpen  nodeShouldCloseCurrentOpen  nodeShouldMakeNewOpen,
	 * given the various types of nodes and containers.
	 * <p>
	 * ASSUMPTION: Every container requires an explicit closing tag
	 * @param e
	 * @return the open container that subsequent elements should use
	 */
	ContainerElement openContainer(DocElement e) {
		ContainerElement ce = (ContainerElement) e.getParent();
		if (doc.getSyntax().subType(e.getType(),PGIPSyntax.CLOSEGOAL)) {
			return (ContainerElement) ce.getParent();
		}
		return ce;
	}

    
    // ========================================================================================
    //
    // Script management calculations --- the heart of script management
    //
    
	/**
	 * Return a list of document elements between the and of the locked region and 
	 * up to a target location (but not _necessarily_ including the char at that offset),
	 * moving the locked position forward to match the last element returned.
	 * This can be used to set up a queue of commands to process.
	 * It is synchronized on the document so that edits cannot change the text as it is queued.
	 * If targetLocn encompasses unparsed text, or the largest region up to the last parsed
	 * position will be considered.
	 * Ihe targetLocn is outside the range getProcessedOffset() - getLength()-1, the empty
	 * list is returned (indicating an invalid pre-condition/argument, but safe return value).
	 * Requires: targetLocn > getLockOffset(), targetLocn >= getParseOffset() >= getLockOffset()
	 * Ensures: fLockedOffset >= targetLocn >= getProcessedOffset(), for valid arguments.
	 * @param targetLocn the location to move the focus to
	 * @author da
	 */
	public synchronized List<CmdElement> lockAndGetCommandsUpto(int targetLocn) throws ProofScriptDocumentException {
		// Check watermarks valid (class invariant)
		doc.checkState();

		// TODO: check possible to go forward, switching queue state here.
		
		ArrayList<CmdElement> cmds = new ArrayList<CmdElement>();

		// Check argument range and pre-condition
		if (getParseOffset() < targetLocn && getParseOffset() >= doc.getLockOffset()) {
			// Move target to last parsed position
			targetLocn = getParseOffset();
		}
		if (getParseOffset() >= targetLocn &&
				targetLocn > doc.getLockOffset() && targetLocn <= doc.getLength()) {

			int cmdLocn = doc.getLockOffset()+1;
			DocElement docelt = null;
			do {
				docelt = findNext(PGIPSyntax.ANYITEM, cmdLocn); // FIXME: check OBO, want command AT this posn.

				if (docelt != null) {
					if (docelt.getPosition().length<=0) {
						//shouldn't happen -- but if parsing does get buggered, bail out rather than loop forever
						throw new ProofScriptDocumentException("parse included command of length 0");
					}
					TypedPosition pos = docelt.getPosition();
					if (pos.getOffset() >= targetLocn) {
						//command starts at or after the indicated location 
						break;
					}
					CmdElement cmd = DocElement.makeCommand(docelt, pos);
					cmds.add(cmd);
					cmdLocn =  docelt.getEndOffset();
					// skip to char before the first non-whitespace after command
					cmdLocn = doc.skipSpacesForward(cmdLocn+1)-1; 
				}				
			} while (docelt != null && cmdLocn+1 < targetLocn);

			if (cmds.size() > 0) {
				int oldlock = doc.getLockOffset() + 1;
				doc.setLockOffset(doc.skipSpacesBackward(cmdLocn)); 
				doc.updateMarkerPositions();
				doc.partitionChangeBroadcast(oldlock, doc.getLockOffset()-oldlock);
				doc.setScriptingState(ScriptingQueueState.FORWARDS);
				doc.checkState();
				return cmds;
			}
		}
		return cmds;
		//no error if no commands (as per javadoc)
//		throw new ProofScriptDocumentException("Document not parsed far enough, invalid target position given or missing parse data: " +
//						Integer.toString(targetLocn));
	}

	/**
	 * Calculate a list of commands to undo back to the given location, and mark
	 * the region between the processed position and there as queued.  Before calling
	 * this method, there must be no queue region in the document (this is not checked).
	 * The target location
	 * must occur before the given location and enough of the document should be parsed.
	 *
	 * @param targetLocn the desired first position of unprocessed text
	 *  (except must do -1 to retract a file) 
	 * @return A list of commands to undo to the nearest location possible in the undo
	 * model which appears at or before the target location.  If there are no completed
	 * commands to undo, an empty list will be returned.
	 * @throws ProofScriptDocumentException if the document is not parsed or processed far enough
	 * @author da
	 * @param sm 
	 */
	public synchronized List<CmdElement> unlockAndGetCommandsBackTo(int targetLocn) throws ProofScriptDocumentException {
 		doc.checkState();

		List<CmdElement> cmds;

		if (getParseOffset() >= targetLocn && targetLocn >= -1 && targetLocn <= doc.getProcessedOffset()) {

			// Move target to a command boundary
			int modifiedTargetLocn = -1;
			DocElement targetcmd = null;
			if (targetLocn>=0) {
				modifiedTargetLocn = doc.skipSpacesForward(targetLocn)+1;
				targetcmd = findPrevious(PGIPSyntax.ANYITEM,modifiedTargetLocn);
			}
//			DocElement firstcmd = findPrevious(PGIPSyntax.ANYITEM,0);
			
//			try {
//	            System.out.println("AH: moving backwards, to remove "+targetcmd.getStartOffset()+"+="+targetcmd.getPosition().length+", "+targetcmd.getText()+" (for "+modifiedTargetLocn+")\n" +
//	            		"  command corresponds to '"+doc.get(targetcmd.getPosition().offset, targetcmd.getPosition().length)+"'\n"+
////	            		"  get(85,1)is '"+doc.get(85,1)+"'\n"+
////	            		"  get(85) is '"+ doc.getChar(85)+"'\n"+
////	            		"  char at modified location is "+((int)doc.getChar(modifiedTargetLocn))+
////	            
////	            		"  char substr is '"+doc.get(targetcmd.getPosition().offset+targetcmd.getPosition().length-1,1)+"'\n"+
////	            		"  substr index we just got is "+ (targetcmd.getPosition().offset+targetcmd.getPosition().length-1)+"+=1\n"+
////	            		"  char at modified location is "+((int)doc.getChar(modifiedTargetLocn))+
//	            		"");
//            } catch (BadLocationException e) {
//            }

			if (targetcmd == null) {
				// we're aiming at/near the start of the document; an abort file should
				// do the trick.  (TODO: check allowed by prover meta model)
				
				CmdElement abort = abortCommandFor(ContainerElement.FILE_LEVEL,
							doc.getProcessedOffset(),targetLocn);
				cmds = new ArrayList<CmdElement>();
				if (abort!=null)
					cmds.add(abort);

			} else {

				targetLocn = targetcmd.getStartOffset();

				cmds = undoCommandsForRegion(targetLocn,doc.getProcessedOffset());
				// TODO: fetch queue position as target location of last commands if any made.
			}

			if (!cmds.isEmpty()) {
				// Leave locked point where it is, move process point backwards to target.
				int oldproc = doc.getProcessedOffset();
				int newproc = cmds.get(cmds.size()-1).getPosition().getOffset()-1;
				doc.setProcessedOffset(newproc);
				doc.updateMarkerPositions();
				doc.partitionChangeBroadcast(newproc+1, oldproc-newproc);
				doc.setScriptingState(ScriptingQueueState.BACKWARDS);
				doc.checkState();
			}

			return cmds;
		}
		throw new ProofScriptDocumentException("Undo in proof script: document not parsed far enough or invalid target position given: " +
					Integer.toString(targetLocn) + " with processed offset " + doc.getProcessedOffset());
	}

	/**
	 * Calculate undo commands for undoing the given region.  Following the PGIP
	 * model, these will be a sequence of abort commands to jump out of a subtree,
	 * followed by a sequence of undo commands on the same level.  For document
	 * elements which do not require undo actions, we queue up SPURIOUSUNDO which
	 * can be used to move the process region at the right moment while processing
	 * the queue.
	 * @param sm 
	 * @param targetLocn
	 * @param processedOffset
	 * @return a list of commands for undoing the given region, non-null but may be empty.
	 */
	public List<CmdElement> undoCommandsForRegion(int targetLocn, int processedOffset) {

		assert targetLocn < processedOffset : "target for undo appears after processed point!";

		ArrayList<CmdElement> cmds = new ArrayList<CmdElement>();

		// TODO: allow use of lockedOffset here, but check that queue is going in right direction.
		
		// Find first command at end of region to undo and
		// last command at end of processed [for iterated undo: locked, TODO] region.
		DocElement docelt = findPrevious(PGIPSyntax.ANYITEM,processedOffset);
		//DocElement lastcmd = findPrevious(PGIPSyntax.COMMAND,getLockOffset());

		// If no command or command ends before region to undo, nothing to do
		if (docelt == null || docelt.getEndOffset() < targetLocn) {
			// Impossible if offset is command boundary and no trailing processed whitespace.
			assert false : "No commands found at end of undo region";
			return cmds;
		}

		// Find common ancestor of [targetLocn, processedOffset], aborting along the way
		ContainerElement container = ContainerElement.getPGIPContainer(doc.getSyntax(),docelt);
		int curpos = processedOffset;
		while (container != null && container != fRootElement) {
			// da: check on fRootElement above prevents abortfile; as a next step we can
			// simplify active script protocol and do that transition here.
			int contstart = container.getStartOffset();
			if (contstart < targetLocn) {
				break;   // found common ancestor
			}
			if (!container.isUndoRentering(doc.getSyntax())) {
				// we must abort this container
				int level = ContainerElement.getPGIPLevel(doc.getSyntax(),container);
				CmdElement abort = abortCommandFor(level+1,curpos,contstart);
				if (abort != null) {
					cmds.add(abort);
					curpos = contstart;                       // curpos is now last processed + 1
					curpos = doc.skipWhiteSpaceBackwards(curpos); // because whitespace elements were stripped, grr!
				}
			}
			container = ContainerElement.getPGIPContainer(doc.getSyntax(),container);
		}

		// If abort hasn't done the job already, find undos on same level
		if (targetLocn < curpos) {
			Stack<CmdElement> undocmds = new Stack<CmdElement>();
			scanForUndos(targetLocn, curpos, container, undocmds);
			while (!undocmds.isEmpty()) {
				cmds.add(undocmds.pop());
			}
		}

		return cmds;
	}

	/**
	 * @param targetLocn
	 * @param curpos
	 * @param container
	 * @param undocmds
	 */
	private void scanForUndos(int targetLocn, int curpos, DocElement container, Stack<CmdElement> undocmds) {

		// Scan elements at the same level forwards, pushing undo commands onto the stack
		List children = container.getChildren();

		int startTarget = container.getPosition().getOffset();
		int curTarget = startTarget;
		if (!children.isEmpty()) {
			boolean times = false; // whether to support times attribute. TODO: get from PGIP config
			int undos = 0;
			int level = ContainerElement.getPGIPLevel(doc.getSyntax(),((DocElement)(children.get(0))));  // FIXME: could pass in
			for (Object child : children) {
				DocElement childcmd = (DocElement) child;
				if (childcmd.getStartOffset() > curpos) {
					break;  // stop undoing
				} else if (childcmd.getEndOffset() > targetLocn) {
					// Something to undo.
					// If it's a container, we may have to look inside recursively
					if (childcmd instanceof ContainerElement) {
						ContainerElement subtree = (ContainerElement) childcmd;
						if (!doc.getSyntax().subType(subtree.getPgiptype(), PGIPSyntax.OPENTYPE)) {
							scanForUndos(targetLocn, curpos, subtree, undocmds);
							continue;
						}
					}
					// Otherwise we can push an undo
					if (times) {
						if (isProverUndoableCommand(childcmd)) {  // only count real undos
							undos++;
						}
					} else {
						Position childpos = childcmd.getPosition();
						CmdElement undo = undoCommandFor(childcmd,level,childpos.getOffset(),childpos.getLength());
						if (undo != null) {
							undocmds.push(undo);
						}
					}
					curTarget = childcmd.getStartOffset();
					curTarget = doc.skipWhiteSpaceBackwards(curTarget);
				}
			}
			if (times) {
				CmdElement undo = undoCommandFor(level,startTarget,curTarget-startTarget);
				if (undo != null) {
					undo.addAttribute("times", Integer.toString(undos));
					undocmds.push(undo);
				}
			}
		}
	}

	/**
	 * Return an abort command which will abort the open element we are
	 * jumping out of during undo.
	 * @param level the nesting depth
	 * @param prevoffset the previous position
	 * @param targetoffset the target position (before prevoffset)
	 * @return a corresponding abort command, or null.
	 */
	// TODO: like other overloadings of DocElement, this should really be a Command
	private CmdElement abortCommandFor(int level, int prevoffset, int targetoffset) {
		if (targetoffset<0) targetoffset = 0;
		if (prevoffset<=targetoffset) 
			return null;
		String abort;
		switch (level) {
		case ContainerElement.FILE_LEVEL:   abort = PGIPSyntax.ABORTFILE;   break;
		case ContainerElement.THEORY_LEVEL: abort = PGIPSyntax.ABORTTHEORY; break;
		case ContainerElement.PROOF_LEVEL:  abort = PGIPSyntax.ABORTGOAL;   break;
		default:                      return null;
		// NB: for level > DocElement.PROOF_LEVEL this gives nothing.
		// So nested proof levels do not have nested histories.
		// ISABELLE SPECIFIC: this may be prover-specific, other provers may do
		// something different with nested proof levels and history.
		// PGIP doesn't yet contain a way to configure this.
		}
		TypedPosition tp = new TypedPosition(targetoffset, prevoffset-targetoffset,UNDO_COMMAND_TYPE);
		return new CmdElement(abort,doc,tp);
	}

	public static final String UNDO_COMMAND_TYPE = "UNDO_COMMAND";

	/**
	 * Construct an undo command for undoing at the given PGIP level, setting
	 * the target location to the given offset.
	 * @param level - the PGIP level of this undo (must be > 0)
	 * @param targetoffset - the offset in the document this command will undo back to
	 * @return a new command, never null.
	 */
	private CmdElement undoCommandFor(int level, int targetoffset, int length) {
		assert level > 0 : "Invalid PGIP level number";
		String undo;
		switch (level) {
			case ContainerElement.FILE_LEVEL:   undo = PGIPSyntax.UNDOITEM; break; // FIXME: Isabelle HACK,
			case ContainerElement.THEORY_LEVEL: undo = PGIPSyntax.UNDOITEM; break; //
			case ContainerElement.PROOF_LEVEL:
			default:                            undo = PGIPSyntax.UNDOSTEP; break;
		// ISABELLE SPECIFIC:
		//  for level > DocElement.PROOF_LEVEL we get undostep, same proof-level undo.
		//  retracttheory isn't used, we retract at the file level instead.  (Isabelle
		//  files with more than one theory will likely go wrong).
		}
		TypedPosition tp = new TypedPosition(targetoffset, length, UNDO_COMMAND_TYPE);
		return new CmdElement(undo,doc,tp);
	}

	/**
	 * Make an undo command for the given element.
	 * @param e
	 * @param level
	 * @param targetoffset
	 * @return an undo command which will be the appropriate one step prover command, the
	 *  spurious undo command, or null if no undo of this element is possible (e.g. because
	 *  it is a custom container which cannot be undone directly itself).
	 */
	private CmdElement undoCommandFor(DocElement e, int level, int targetoffset, int length) {
		if (isProverUndoableCommand(e)) {
			return undoCommandFor(level,targetoffset,length);
		}
		if (isSpuriousUndoableCommand(e)) {
			TypedPosition tp = new TypedPosition(targetoffset,length,UNDO_COMMAND_TYPE);
			return new CmdElement(PGIPSyntax.SPURIOUSUNDO,doc,tp);
		}
    	return null;
	}

	/**
	 * See if the given element is undoable (in one undo step) in the prover.
	 * @param e
	 * @return true if the command is undoable
	 */
	protected boolean isProverUndoableCommand(DocElement e) {
		if (doc.getSyntax().subType(e.getType(), PGIPSyntax.COMMAND)) {
			return true;
		}
		if (e instanceof ContainerElement) {
			ContainerElement ce = (ContainerElement) e;
			return doc.getSyntax().subType(ce.getPgiptype(),PGIPSyntax.OPENTYPE);
		}
		return false;
	}

    /**
     * See if the given element is "spurious" undoable.  In this case,
     * a "fake" command which is not sent to the prover is queued up, but used
     * to move the processed position at the right moment.
     * @return true if the command is undoable "spuriously"
     */
    protected boolean isSpuriousUndoableCommand(DocElement e) {
    	if (doc.getSyntax().subType(e.getType(), PGIPSyntax.ANYITEM)) {    // e.g. comments, spuriouscmd
    		return true;
    	}
    	return false;
    }


	/**
	 * Search for an element starting (strictly) before offset.
	 * @param type The element type to find. Also finds subtypes.
	 * @param offset the offset to search up to
	 * @return the matching element, or null if none found.
	 */
	public DocElement findPrevious(String type, int offset) {
		final int off = offset;
		final String ftype = type;
		Fn fn = new Fn() {
			public Object apply(Tree node) {
				DocElement e = (DocElement) node;// BC ??
				if (e.getPosition()==null || e.getPosition().offset >= off) {
					return null;
				}
				if (doc.getSyntax().subType(e.getType(),ftype)) {
					return e;
				}
				return null;
			}
		};
		return (DocElement) TreeWalker.reverseTreeWalk(fRootElement,fn);
	}

    /**
     * Find an element after the given offset.
     * @param type the PGIP type to search for
     * @param offset the offset from which to search.
     * @return the discovered elemenent
     */
	// TODO: ==> ScriptModel
    public DocElement findNext(String type, final int offset) {
      final String ftype = type;
      //final PGIPSyntax syntax = doc.syntax;
      TreeWalker.Fn fn = new TreeWalker.Fn() {
          public Object apply(TreeWalker.Tree node) {
              DocElement e = (DocElement) node; // BC
              if (e.getPosition()==null || e.getPosition().offset<offset) {
				return null;
			}
              if (doc.getSyntax().subType(e.getType(),ftype)) {
				return e;
			}
              return null;
          }
      };
      return (DocElement) TreeWalker.treeWalk(fRootElement,fn);
  }

    
	public boolean isFullyParsed() {
	    int length = doc.getLength();
	    int parseOffset = getParseOffset();
	    if (parseOffset >= length-1) {
	    	return true;
	    }
	    try {
	    	// FIXME: this could be more efficient: just look at first few chars or so.
	    	// Or we could maintain a "fully parsed" flag.
	        if (StringManipulation.isWhitespace(doc.get(parseOffset+1,length-parseOffset-1))) {
	        	return true;
	        }
	    } catch (BadLocationException ex) {}
		return false;
	}

    
	/**
     * @return the fParsedRegion
     */
    public ScriptManagementPosition getParsedRegion() {
    	return fParsedRegion;
    }


	/**
     * @return the root of the parse tree 
     */
    ContainerElement getRootElement() {
	    return fRootElement;
    }


	/**
     * @return the open element, or null if none
     */
    public ContainerElement getOpenElement() {
	    return fOpenElement;
    }

	
}
