/*
 *  $RCSfile: TEMPORARY-ParserNew.java.tmp,v $
 *
 *  Created on 09 Sep 2004 by Daniel Winterstein
 *  part of Proof General for Eclipse
 */
package ed.inf.proofgeneral.editor.lazyparser;
import java.util.Iterator;

import org.dom4j.CharacterData;
import org.dom4j.Element;
import org.dom4j.Node;
import org.eclipse.jface.text.BadLocationException;
import org.eclipse.jface.text.IRegion;
import org.eclipse.jface.text.Position;
import org.eclipse.jface.text.TypedPosition;

import ed.inf.proofgeneral.Constants;
import ed.inf.proofgeneral.ProofGeneralPlugin;
import ed.inf.proofgeneral.document.ContainerElement;
import ed.inf.proofgeneral.document.DocElement;
import ed.inf.proofgeneral.document.ProofScriptDocument;
import ed.inf.proofgeneral.editor.actions.PGMarkerMethods;
import ed.inf.proofgeneral.pgip.Fatality;
import ed.inf.proofgeneral.sessionmanager.PGIPSyntax;
import ed.inf.proofgeneral.sessionmanager.ScriptingException;
import ed.inf.proofgeneral.symbols.HTMLSymbols;
import ed.inf.utils.datastruct.StringManipulation;

/**
 * The base class for script parsers. Extend this class (or subclasses)
 * to create a new parser - then edit SessionManager to get your new parser used.
 * This base class provides some generic functionality for linking a parseresult with a document.
 * This job is made harder by:
 *
 * 1) The parseresult may mangle whitespace and linebreaks.
 * 2) The parseresult may mix elements whose xml markup is generated by the parser
 * (ie. normal proof script elements),
 * and elements whose xml markup appears in the text (ie. interface script elements).
 *
 * @author Daniel Winterstein
 */
public abstract class Parser {

	/**
	 *
	 */
	public static class ParsingInterruptedException extends Exception {
		public ParsingInterruptedException(String text) {
			super(text);
		}
	}

	/**
	 * Determines whether this parser is slow (and should not be allowed to block) or fast
	 * @return whether or not this parser is slow (true=slow)
	 */
	public abstract boolean isSlow();

	/** @return whether this parser can give the next command really quickly
	 *  (and thus doesn't need to be put in a separate thread, eg by SendCommandAction)
	 */ //added by -AH to fix bug where go-to-line doesn't work
  public boolean hasNextCommandFast(ProofScriptDocument doc, String type) {
  	if (!isSlow()) {
		return true;
	}
    int so = Math.max(doc.getProcessedOffset() + 1,0);
    DocElement e = doc.findNext(type,so);
    return (e!=null);
	}
	/** @return whether this parser can give the next command of type COMMAND really quickly
	 *  (and thus doesn't need to be put in a separate thread, eg by SendCommandAction)
	 */ //added by -AH to fix bug where go-to-line doesn't work
  public boolean hasNextCommandFast(ProofScriptDocument doc) {
  	return hasNextCommandFast(doc, PGIPSyntax.COMMAND);
	}

	/**
	 * The action that initiated the current/latest parse.
	 * Used with external parsers to co-ordinate the response.
	 * Should be set to null when the parse is finished.
	 */
	Object cause = null;
    /**
     * @param cause The action that initiated this parse. Used with external parsers to co-ordinate the response.
     */
    public void setCause(Object cause) {
        this.cause = cause;
    }

	public Parser(PGIPSyntax syntax) {
		this.syntax = syntax;
	}
	/**
	 * The syntax object to be used in parsing
	 */
	PGIPSyntax syntax;

    /**
     * Return a list of DocElements
     * @param text
     * @return
     * @throws ScriptingException
     */
    //public abstract List parse(String text) throws ScriptingException;

    /**
     * Parse document from offset for the given length, updating the document's parse tree.
     * @param doc
     * @param offset
     */
    public synchronized void parseDoc(ProofScriptDocument doc, int offset, int length)
    throws BadLocationException,ScriptingException {
    	String text = doc.get(offset, length);
    	PGMarkerMethods.cleanMarkers(doc, offset,length); // NB: this removes *all* markers

     	Element parseResult = parseText(text,doc,offset);
    	linkParse(parseResult,doc,offset,text);
    }

    /**
 	Returns the next command for sending out to the TP
 * @param doc
 * @return DocElement */
    public synchronized DocElement findNextCommand(ProofScriptDocument doc)
    throws ScriptingException {
    	return findNextCommand(doc, PGIPSyntax.COMMAND);
    }
    /**
   	Returns the next element of the specified type, for sending out to the TP
   * @param doc
   * @return DocElement */
      public synchronized DocElement findNextCommand(ProofScriptDocument doc, String type)
      throws ScriptingException {
          int so = Math.max(doc.getProcessedOffset()+1, 0);
          DocElement e = doc.findNext(type, so);
          if (e != null) {
			return e;
		}
          return findObject(type, doc, so);
      }
      public synchronized DocElement findNextCommandFast(ProofScriptDocument doc, String type) {
          int so = Math.max(doc.getProcessedOffset()+1, 0);
          DocElement e = doc.findNext(type, so);
          if (e != null) {
			return e;
		}
          return null;
      }

    public synchronized DocElement findObject(String type,ProofScriptDocument doc, int startOffset)
    throws ScriptingException {
    	return findObject(type,"",doc,startOffset);
    }

    /** finds the next object, by following a programmed list of non-blank lines to jump;
     *  use strategy to add 1 line, then 3, then 12, then the whole shebang */
    public synchronized DocElement findObject(String type, String preLine,
				 ProofScriptDocument doc, int startOffset)
    throws ScriptingException
		{
    	// DA Sep 06: FIXME: the strategy here (or in linkObject) is flawed because we can
    	// have valid commands which are prefixes of valid commands (e.g. constdefs).
    	// What should be done is to find two successive command beginnings
    	// (like in the Emacs code...).  Since the parsing efficiencies have been fixed
    	// in the current Isabelle CVS, I've added a preference to control whether
    	// this dodgy strategy is used or not.  Nonetheless, it might be desirable
    	// to re-activate this code because editing at the start of a long document
    	// causes long delays in reparsing.
    	int intervals[] = { 1, 3, 12, 36, 108, 432, -1 };
    	boolean useintervals =
    		ProofGeneralPlugin.getBooleanPref(Constants.PREF_USE_GATHERING_PARSER);
    		return findObject(type, preLine, doc, startOffset,
    				 		  useintervals ? intervals : new int[] { -1 } );
		}


    /**
     * Parse ahead looking for objects
     * Returns null if it hits the end of file without finding anything
     * @param type
     * @param preLine
     * @param doc
     * @param startOffset
     * @param linesToAdd an array of the number of lines to add at a time
     * @return the discovered object matching specification
     * @throws ScriptingException
     */
    public synchronized DocElement findObject(String type, String preLine,
            					 ProofScriptDocument doc, int startOffset, int[] linesToAdd)
    throws ScriptingException
    {
        IRegion r;
        String line = "";
        int endOffset = -1;
        int lineNo = -1;
        int offset = startOffset;
        int linesAdded = 0;
        try {
            lineNo = doc.getLineOfOffset(offset);
            do {
                r = doc.getLineInformation(lineNo);
                endOffset = r.getOffset() + r.getLength();
                if (endOffset <= offset) {
                    // startOffset is a line delimiter; move on to the next line
                    lineNo++;
                    continue;
                }
                line += doc.get(offset, endOffset-offset);   //TODO should use a stringbuffer instead...
                offset += endOffset-offset;
                if (!StringManipulation.isWhitespace(line)) {
					linesAdded++; // don't send empty lines
				}
                lineNo++;
            } while (linesToAdd[0]==-1 || linesAdded<linesToAdd[0]);
        } catch(BadLocationException ex) {
        	//reached end of file
        	if (linesAdded==0) {
				return null;
			}
        }
        Element parseResult;
        try {
        	parseResult = parseText(preLine+line, doc, startOffset);
        	//System.out.println("result of parse from "+startOffset+" (of "+(preLine+line).length()+" chars) is "+parseResult.elements().size()+" elements");
        	//if (parseResult.elements().size()>8 && startOffset>60) ...
        } catch (ScriptingException ex2) {
        	//doesn't usually throw UnparseableException
        	if (ex2 instanceof UnparseableExceptionException) {
        		return findObject(type,preLine+line,doc,endOffset,dropFirstFromArray(linesToAdd));
        	} else {
				throw ex2;
			}
        }

        try {
        	linkParse(parseResult,doc,startOffset - preLine.length(),preLine+line);   //should be this, i think -AH
        	//linkParse(parseResult,doc,startOffset,preLine+line);
        } catch (UnparseableExceptionException x) {
        	// perhaps the UnparseableException bit is below our element?
        	DocElement e = doc.findNext(type,startOffset - preLine.length());
        	if (e != null) {
				return e;
			}
        	DocElement foundElt = null;
        	//System.out.println(General.makeDateString()+"  expanding parse starting at "+(startOffset-preLine.length())+", size "+(linesToAdd[0]));
        	foundElt = findObject(type,preLine+line,doc,endOffset, dropFirstFromArray(linesToAdd));
        	//System.out.println(General.makeDateString()+"  expanded parse starting at "+(startOffset-preLine.length())+", size "+(linesToAdd[0])+"; result "+(foundElt==null ? "null" : "FOUND"));
        	if (foundElt!=null) {
				return foundElt;
			}
        	//if we got null, we are at end of doc, and UnparseableException
        	throw x;
        }
        DocElement e = doc.findNext(type,startOffset - preLine.length());
        if (e != null) {
			return e;
		}
        try {
            int nextOffset = doc.getLineOffset(1+lineNo);
            return findObject(type,"",doc, nextOffset);
        } catch (BadLocationException ex) {
            throw new ScriptingException("Exception when looking for a command. "+ex.getMessage());
        }
    }


    /**
     * Removes the first item from an array, if it contains more than one element.
     * @param in the array to modify
	 * @return a new array, minus the first element of the given array
	 */
    // FIXME da: library function?  Do we need to make a new array here?
	private int[] dropFirstFromArray(int[] in) {
		int drop = (in.length > 1 ? 1 : 0);
		int[] out = new int[in.length - drop];

		for (int i = 0; i < out.length; i++) {
			 out[i] = in[i+drop];
		}
		return out;
	}

    /**
     * Parse the rest of the document from offset. Wrapper for parseDoc/4
     * @param doc
     * @param offset
     * @throws BadLocationException
     * @throws ScriptingException
     */
    public void parseDoc(ProofScriptDocument doc, int offset)
    throws BadLocationException,ScriptingException {
    if (doc.getLockOffset() > offset) {
    	System.err.println("Warning:  Parser.parseDoc called to parse from "+offset+"; but buffer is locked to "+doc.getLockOffset());
    }
    if (doc.getProcessedOffset() > offset) {
    	System.err.println("Warning:  Parser.parseDoc called to parse from "+offset+"; but buffer is processed to "+doc.getProcessedOffset()+": parsing from processed point");
    	offset = doc.getProcessedOffset();
    }
    try {
    	if (offset<doc.getParseOffset()) {
      		doc.setEditOffset(offset); // throw away old parse information
      	}
     } catch (Exception e) {
      	System.err.println("Error setting offset in Parser.parseDoc: "+e);
      	e.printStackTrace();
     }
     	parseDoc(doc, offset, doc.getLength()-offset);
    }

    /**
     * Parse the text, returning a <parseresult> element, containing the parse results (elements and/or errors).
     * Use in preference to dumbParseText where doc is known, as it allows the parser to use context.
     * The default implementation just calls dumbParseText
     * @param text
     * @return the parsed element
     * @throws ScriptingException
     */
    public Element parseText(String text,ProofScriptDocument doc,int offset) throws ScriptingException {
    	return dumbParseText(text);
    }
    /**
     * Parse text, ignoring issues regarding document partitions.
     * For this reason, you should use parseText in preference where possible.
     * @param text
     * @return parse result
     * @throws ScriptingException
     */
    public abstract Element dumbParseText(String text) throws ScriptingException;

    /**
     * Exception to signal that some text was UnparseableException
     */
    public static class UnparseableExceptionException extends ScriptingException {

        UnparseableExceptionException(String msg) {
            super(msg);
        }
    }

    /**
     * Convert the parse result into doc elements
     * @param parseResult (containing a list of Elements)
     * @param doc the document to notify of our events
     * @param startOffset the starting offset
     * @throws UnparseableExceptionException if the parse result was not good.
     */
    public void linkParse(Element parseResult, ProofScriptDocument doc,
            				int startOffset, String rawText)
    throws UnparseableException {
        try {
            linkParse(parseResult.elements(),doc,startOffset,rawText);
        } catch (UnparseableException ex) {
            try {
            	// da: added +1 in three places below, seemed to be OBO.  Doesn't stop
            	// assertion failures, though, perhaps these are due to non-changes
            	// in document?
                doc.fireParseTreeChangedEvent(startOffset,
                		(doc.getParseOffset()>startOffset ? doc.getParseOffset()-startOffset+1 : 0));
            } catch (Exception ex2) { ex2.printStackTrace(); }
            throw ex;
        }
        if (doc.getParseOffset()<=startOffset) {
        	//we've done nothing, probably at end of document
        	return;
        }
        try {
            doc.fireParseTreeChangedEvent(startOffset,doc.getParseOffset()-startOffset+1);
        } catch (Exception ex) {
        	//don't worry about this out of debug mode
        	//(it seems pretty common when starting without causing any problems), eg
        	/*
start-offset:0 offset:22 doc-length:54
org.eclipse.jface.text.Assert$AssertionFailedException: Assertion failed:
        at org.eclipse.jface.text.Assert.isTrue(Assert.java:189)
        at org.eclipse.jface.text.Assert.isTrue(Assert.java:174)
        at org.eclipse.ui.internal.texteditor.quickdiff.compare.equivalence.DocEquivalenceComparator.<init>(DocEquivalenceComparator.java:47)
        at org.eclipse.ui.internal.texteditor.quickdiff.DocumentLineDiffer.handleChanged(DocumentLineDiffer.java:916)
        at org.eclipse.ui.internal.texteditor.quickdiff.DocumentLineDiffer.documentChanged(DocumentLineDiffer.java:762)
        at org.eclipse.jface.text.AbstractDocument.doFireDocumentChanged2(AbstractDocument.java:729)
        at org.eclipse.jface.text.AbstractDocument.doFireDocumentChanged(AbstractDocument.java:692)
        at org.eclipse.jface.text.AbstractDocument.doFireDocumentChanged(AbstractDocument.java:677)
        at ed.inf.proofgeneral.editor.ProofScriptDocument.fireParseTreeChangedEvent(ProofScriptDocument.java:153)
        at ed.inf.proofgeneral.editor.lazyparser.Parser.linkParse(Parser.java:404)
        at ed.inf.proofgeneral.editor.lazyparser.Parser.findObject(Parser.java:235)
        at ed.inf.proofgeneral.editor.lazyparser.Parser.findObject(Parser.java:177)
        at ed.inf.proofgeneral.editor.lazyparser.Parser.findObject(Parser.java:166)
        at ed.inf.proofgeneral.editor.lazyparser.Parser.findNextCommand(Parser.java:127)
        at ed.inf.proofgeneral.editor.actions.SendCommandAction$BgParse.run(SendCommandAction.java:182)
        at ed.inf.heneveld.utils.process.ThreadPool$PooledThread.run(ThreadPool.java:172)
        	 */
        	if (ProofGeneralPlugin.debug(this)) {
        		System.err.print("Exception firing ParseTreeChangedEvent ");
        		System.err.println( "start-offset:"+ startOffset + " parse offset:"+doc.getParseOffset() +
        				" length:" + (doc.getParseOffset()-startOffset+1) +  " doc-length:"+doc.getLength() );
        		// ex.printStackTrace()
        		/*
        		try {
        			doc.fireParseTreeChangedEvent(Math.max(0,startOffset),
        					Math.min(doc.getLength()-Math.max(0,startOffset),
        							(doc.getParseOffset()>startOffset ? doc.getParseOffset()-startOffset : 0)));
        		} catch (Exception ignore) {}
        		*/
        	}
        }
    }

    /**
     * Create a container element for any content.
     * Add it to the proof parse tree and set it as the new open element.
     * @param doc
     * @param startOffset - cEnd+1
     * @param type - the name of the elemnt in the tree
     * @param pgiptype - the PGIP open-type which corresponds to this container, or null if none.
     */
    void createOpenElement(ProofScriptDocument doc, int startOffset, String type, String pgiptype) {
      ContainerElement pf = new ContainerElement(type, doc,pgiptype);
      pf.setPosition(new TypedPosition(startOffset, 0, type));
      doc.getOpenElement().add(pf);
      pf.open = true;
      doc.setOpenElement(pf);
    }

    /**
     * Recursive method that does the work for linkParse, linking elements into the
     * document and creating error markers for parse errors and warnings.
     */
    void linkParse(List<Element> nodes, ProofScriptDocument doc,
			int startOffset, String rawText) throws UnparseableException {
    	int offset = startOffset;
        String eText;
        //DocElement parent = doc.getOpenElement();
        UnparseableException parseError = null;    // keep any fatal parsing error until the end
        for (Element node : nodes) {
             if (syntax.subType(node.getName(),PGIPSyntax.ERRORRESPONSE) ) {
				parseError = linkParseParseError(doc, offset, parseError, node);
             } else {
            	Position p=null;
            	p = findMatch(node,rawText);
            	if (p!=null) {
            		// da: I don't want to strip whitespace (although would prefer it in element suffix)
            		// eText = rawText.substring(0,p.offset+p.length);
            		eText = rawText.substring(p.offset,p.offset+p.length);
            	} else {
            		// da: this *shouldn't* happen for good parse results... I want to understand when it goes wrong
            		System.err.println("Mismatch found in parseresult at position "+startOffset+" for node contents: \""+node.getStringValue()+"\"");
            		eText = node.getText();
            	}
            	//  internal commands are wrapped in extra xml  [???]
            	// da: don't want this.  Skip space in marker code.
            	//eText = StringManipulation.trim(eText); // some protection against \r\n = \n wierdness. Also stops markers being positioned on earlier (empty) lines.
            	//TODO we should take the position as the next in the doc after fParseOffset, and this below should just be a check; but this is working
            	int gap = rawText.indexOf(eText);
            	// da: if the text was found, check that only whitespace was given
            	// first.
            	// debug:
            	//if (gap > -1) {
            	//	System.out.println("Found match for element "+node.getName()+" with gap " + gap);
            	//	if (!rawText.substring(0, gap).matches("[ \\n]+")) { // FIXME regexp
            	//		// Match was later in text, don't take it.
            	//		gap = -1;
            	//	}
            	//}
            	// attempt to correct for whitespace and linebreak issues.
            	Position truePosn = null; // lots of potential for out-by-1-or-2 errors
            	if (gap==-1) {
//            		 FIXME da: very buggy, only matches part of element text, allows spaces anywhere!
            		truePosn = findMatch(eText,rawText);
            		if (truePosn != null) {
						gap = truePosn.offset;
					} else {
            			//added by AH to try to fix symbol discrepancies ("Rough" is a hack, but this sounds pretty good)
            			truePosn = findMatchModSymbols(eText,rawText);
            			if (truePosn != null) {
							gap = truePosn.offset;
						}
            		}
            	} else {
            		truePosn = new Position(gap,eText.length());
            	}

            	if (gap!=-1) {
            		offset += gap;
            		rawText = rawText.substring(gap);
            	} else {
            		//if (ProofGeneralPlugin.debug())
            		System.err.println("Possible Error: linkParse found a gap of -1 in element "+eText);
            		// leave offset alone and hope for the best
            	}
            	// da: this *can't* happen, we got here by choosing elements...
            	// if (node instanceof CharacterData) {
            	// parent.addText(node.getText());

            	// don't add empty elements into the tree
            	// FIXME da: this breaks the possibility for the tree to reconstruct the raw text (i.e. be a model).
            	if (StringManipulation.isWhitespace(eText) || PGIPSyntax.WHITESPACE.equals(node.getName())) {
            			continue;  //if (!node.hasContent()) continue;
            	}

            	// Make the new element.
            	if (p!=null) {
            		DocElement docE = linkElement(node,doc,offset,rawText,false,p.length);
            		docE.rawText = eText; // avoid setting this where possible, because it will probably cause bugs
            	} else {
            		int length = truePosn==null? -1 : truePosn.length;
            		DocElement docE = linkElement(node,doc,offset,rawText,false,length);
            		eText = StringManipulation.trim(docE.getText());
            		//  da: I'd prefer it if the tree text matches the doc, for sensible consistency
            		// eText = docE.getText();
            	}
            	offset += truePosn!=null? truePosn.length : eText.length();
            	rawText = rawText.substring(truePosn!=null? truePosn.length : eText.length());
             }
        }
        if (parseError!=null) {
        	throw parseError;
        }
    }

	/**
	 * @param doc
	 * @param offset
	 * @param parseError
	 * @param node
	 * @return
	 * @throws UnparseableException
	 */
	private UnparseableException linkParseParseError(ProofScriptDocument doc, int offset, UnparseableException parseError, Node node) throws UnparseableException {
		/*
		 * parsing errors: these are different to normal error messages because
		 * they are embedded in the parseresult message and by convention
		 * precede an <UnparseableException> sequence. So the main event loop does not
		 * add markers for parse errors. That's just as well because it allows
		 * us to calculate the regions affected here, and the messages (from
		 * Isabelle, as of Jan 07) do not include location information
		 * themselves. We could consider flattening the structure when Isabelle
		 * gets better at reporting locations, but this will need changes in the
		 * Broker too. - da.
		 *
		 */

		Fatality fatality = Fatality.fromString(((Element)node).attributeValue("fatality"));
		// The next two cases could maybe be combined.
		if (!fatality.commandFailed()) { // set a problem marker and carry on. should be only case, really.
			try {
				// FIXME NB: addMarker in PGMarkerMethods already uses a runnable, although its scope
				// might be widened.
				String msg = parseError != null ? parseError.getMessage() : ((Element) node).getStringValue();
				int errorOffset = offset;
				try {
					while (Character.isWhitespace(doc.getChar(errorOffset))) {
						errorOffset++;
					}
				} catch (Exception e) { // nothing
				}
				PGMarkerMethods.addProblemMarker(doc,
						new Position(errorOffset,node.getText().length()), // FIXME: use location if set
						-1,
						"Parse problem: "+msg.replaceFirst("\n.*","..."),
						msg,
						fatality.markerSeverity());
			} catch (Exception x) {
				x.printStackTrace();
				throw new UnparseableException(node.getStringValue());
			}
			// A fatal error usually terminates the parse with the rest being UnparseableException.
		} else if (fatality == Fatality.FATAL) {
			if (parseError==null) {
				parseError = new UnparseableException(node.getStringValue());
			}
			//note we assume the result comes as
			//<errorresponse .../> .... <UnparseableException .../> ....
			//and we keep loading nodes after errors, except for the 'UnparseableException' bit
			//that allows us to set any valid parse info returned
			if (syntax.subType(node.getName(),PGIPSyntax.UnparseableException)) {
				//set firstErrorOffset if we are element "UnparseableException" and we get here
				if (parseError.errorDoc==null) {
					parseError.errorDoc = doc;
					parseError.errorOffset = offset;
					//we've got to skip whitespace also
					try {
						while (Character.isWhitespace(doc.getChar(parseError.errorOffset))) {
							parseError.errorOffset++;
						}
					} catch (Exception e) {}
					// da: added next line to add a marker.
					// FIXME: this probably shouldn't be done if we haven't parsed the complete rest-of-document,
					// using the "gathering" strategy, since we'll see a succession of markers added!!
					// Probably simply disable this in this code (and hope we never need "gathering" again).
					String msg = parseError.getMessage();
					PGMarkerMethods.addProblemMarker(doc,
							new Position(parseError.errorOffset,node.getText().length()),  // FIXME: use location if set
							-1, "Parse error: "+msg.replaceFirst("\n.*","..."),
							msg,
							fatality.markerSeverity());
				}
				throw parseError;  //throw this when we get to the 'UnparseableException' node
				//(but use the text from the 'errorResponse' node)
			}
		}
		return parseError;
	}
    /**
     * Create a DocElement (with typed position) from an element
     * and add it to the current open container of the document.
     *
     * Attaches comments to elements, where possible, for use as tooltips/hover help.
     *
     * This implements part of the spec for how proof scripts are set out
     * ASSUMPTION: a theorem is followed by a proof
     *
     * @param e the element to convert
     * @param doc			the document to notify
     * @param offset		the offset of the element
     * @param rawText		the text of the element
     * @param fireEvents	should be true, unless the calling function intends to fire
     * 						a bulk event (eg. it is doing a big parse, and doesn't want to
     * 						slow the system down with lots of little events)
     * @param length		Set to -1 if the length is unknown
     * @return the converted Element
     */
    @SuppressWarnings("unchecked")
	public DocElement linkElement(Element e, ProofScriptDocument doc, int offset,
            						String rawText,boolean fireEvents, int length)
    throws UnparseableException {
        DocElement de;
        String name = e.getName();

        ContainerElement addPt = doc.getOpenElement();

        // TODO da: we should defer some of this structuring to Isabelle's parser.
        // Sections can be handled with openblock/closeblock markup which is currently
        // added for proof structure and indentation hints too.

        if (syntax.subType(name, PGIPSyntax.DOCCOMMENT)) { // FIXME da: Isabelle-specific
        	if (e.getStringValue().startsWith("subsection")) {
        		//close the previous open element when we get here
            if (addPt != doc.getRootElement()) {
              doc.closeOpenElement();
              addPt = doc.getOpenElement();
            }
        	}
        }

        DocElement previous = addPt.getLastElement();

        TypedPosition posn = new TypedPosition(offset,0,name);
        if (e.elements().size()!=0) {
        	// da: commentary:
        	// If the node we're adding has elements, we make a container element for them.
        	// Since PGIP markup is flat (i.e. no nested elements), I don't think this case
        	// should occur.
        	assert false : "PGIP parser has returned nested elements";
        	System.err.println("Making container for parse element with name: " + name); // TEMP
        	de = new ContainerElement(name,doc,null);
        }
        else {
        	ContainerElement ce = ContainerElement.containerForElement(e, doc);

        	if (ce!=null) {

        		//HACK! check we don't already have one similar, if we do we may have to remove it
        		// FIXME da: why and when does this happen?
        		DocElement le = addPt.getLastElement(), lle = le;
        		while (le!=null && le instanceof ContainerElement) {
        			lle = le;
        			le = ((ContainerElement)le).getLastElement();
        		}
        		if (lle.getPosition().offset+lle.getPosition().length >= posn.offset+posn.length) {
        			// da: I see this quite often.  Add some more debug info
        			System.err.println("may already have container in tree!!");
        			if (ProofGeneralPlugin.debug(this)) {
        				System.err.println("Document element being added is: \n" + e.toString());
        				System.err.println("Container element being added is: " + ce.toString());
        				System.err.println("Container element already there is: " + le.toString());
        			}
        		}
        		addPt.add(ce);
        		doc.setOpenElement(ce);
        		ce.open = true;
        		// TODO da: it's supposed to be possible to have positions move with the document,
        		// can we do this?  Positions are used everywhere but regions seem to be enough.
        		ce.setPosition(new TypedPosition(offset, 0, ce.getName()));
        		//will need length eventually... should get it automatically
        		addPt = doc.getOpenElement();
        	}
        	de = new DocElement(name,doc);
        }

        if (de instanceof ContainerElement) {
        	doc.setOpenElement((ContainerElement)de);
        	// recursive call to linkParse
        	linkParse(e.elements(), doc, offset, rawText);
       		doc.closeOpenElement();
        } else {
            // da: I removed .trim.  Better to take the text as given
        	de.setText(e.getText());
        }

        de.setPosition(posn);
        de.setAttributes(e.attributes());
        addPt.add(de);

        // give this element some length
        if (length==-1) {
            posn.length = de.getText().length();
        } else {
        	posn.length = length;
        }
        int cEnd = offset + posn.length;
        ContainerElement ce = addPt;
        while (ce!=null) {
        	//set container length on all nodes up the hierarchy
          ce.getPosition().length = cEnd - ce.getPosition().offset;
          ce = (ContainerElement)ce.getParent();
        }

        if (syntax.subType(name,PGIPSyntax.OPENGOAL)) {
        	//do this above instead
            // create a proof element to contain the proof
            // starting just after the opentheorem command
            //createProofElement(doc,cEnd+1);
        } else
        if (syntax.subType(name,PGIPSyntax.CLOSEGOAL)) {
        	//this needs to close the open element, once we have beenadded
            if (!syntax.subType(addPt.getType(),
            		//PGIPSyntax.PROOF
            		PGIPSyntax.PROOF_CONTAINER
            		)) {
                throw new UnparseableExceptionException("A close theorem command appears without a corresponding open theorem");
            }
            if (addPt != doc.getRootElement()) {
                doc.closeOpenElement();
            } else { // tried to close the root element
            	// TODO: better recovery/reporting here.
                System.err.println("syntax error in script - too many closing elements");
            }
        }

        // if the previous element was a comment, and this one is not a comment
        // then create a tooltip for our new element.
        if (previous !=null && syntax.subType(previous.getType(),PGIPSyntax.COMMENT)
                //&& !syntax.subType(previous.getType(),PGIPSyntax.DOCCOMMENT)
                && !syntax.subType(name,PGIPSyntax.COMMENT)) {
            de.setTooltip(previous.getText());
        }

        doc.createMarker(de); // must be called after de.setTooltip()

        try {
            if (fireEvents) {
				doc.fireParseTreeChangedEvent(offset,cEnd-offset);
			}
            doc.setParseOffset(cEnd);
        } catch (Exception ex) {
            ex.printStackTrace();
        }
        if (ProofGeneralPlugin.debug(this)) { //DEBUG-TEST-CODE
            try {
                String deText = de.getText();
                String docText = doc.get(de.getPosition().offset,de.getPosition().length);
                assert findMatch(deText,docText) != null : "Mismatch in parser: "+deText+" != "+docText;
            } catch (Exception x) {x.printStackTrace();}
        } //END-DEBUG
        return de;
    }

    /**
     * Try to match the xml of an element against the beginning of the raw text.
     * Ignores white-space and quote marks, since these can be changed by XML parsers.
     * ASSUMPTION: This will <b>not</b> spot that &lt;dummy&gt;&lt;/dummy&gt; = &lt;dummy/&gt;;
     *  I am assuming this kind of syntax switch won't occur.
     * @return position indicating start and length relative to the raw text supplied, or null if the match failed.
     */
    public static Position findMatch(Element e,String rawText) {
    	// FIXME da: crummy code again.  Shouldn't use exceptions as matter of course.
    	try {
            String name = e.getName();
            String asXML = e.asXML();
            int start = rawText.indexOf(name)-1;
            if (start<0) {
				return null;
			}
            int j=start;
            for(int i=0; i<asXML.length(); i++) {
                char xc = asXML.charAt(i);
                if (ignore.indexOf(xc) != -1) {
                	continue;
                }
                while(true) {
                    char rc = rawText.charAt(j);
                    if (ignore.indexOf(rc)!= -1) {
                        j++; continue;
                    }
                    if (xc==rc) {
                        j++;
                        break;
                    }
                    return null;
                }
            }
            return new Position(start,j-start);
        } catch (Exception ex) {
            return null;
        }
    }
    // FIXME da: I don't think we should be ignoring whitespace at all.
    static final String ignore =" \r\n\t";  //don't think we should be ignoring ' and "  -AH


    /**
     * Try to match text against the beginning of the raw text, ignoring whitespace and \r\n / \n differences.
     * @return position indicating start and length relative to the raw text supplied, or null if the match failed.
     */
     // da: FIXME: pretty sloppy stuff.  Use of exceptions isn't great,
     // (possibly odd return values when text prefix matches at end of string?)
     // Also, this matches "h e l l o" against "hello" which we don't want.
    public static Position findMatch(String eText,String rawText) {
    	assert !(eText.equals("") || rawText.equals("")): "Empty input";
        try {
        int start=-1,j=0;
        for(int i=0; i<eText.length(); i++) {
            char ec = eText.charAt(i);
            if (ignore.indexOf(ec) != -1) {
            	continue;
            }
            while(true) {
                char rc = rawText.charAt(j);
                if (ignore.indexOf(rc)!= -1) {
                    j++; continue;
                }
                if (ec==rc) {
                    if (start==-1) {
						start = j;
					}
                    j++;
                    break;
                }
                return null;
            }
        }
        if (start==-1) {
			return null;
		}
        return new Position(start,j-start);
        } catch (Exception ex) {
            return null;
        }
    }

    public static Position findMatchModSymbols(String eText, String rawText) {
    	try {
    		int ei=0, ri=0;
    		while (ei<eText.length() && Character.isWhitespace(eText.charAt(ei))) {
				ei++;
			}
    		while (ri<rawText.length() && Character.isWhitespace(rawText.charAt(ri))) {
				ri++;
			}
    		int start=ri;
    		while (ei<eText.length() && ri<rawText.length()) {
    			if (eText.charAt(ei)==rawText.charAt(ri)) {
    				ei++;
    				ri++;
    			} else {
    				int mis[] = prover.getSymbols().checkStringsStartSameSymbol(eText, ei, rawText, ri);
    				if (mis!=null) {
    					ei += mis[0];
    					ri += mis[1];
    				} else {
    					System.err.println("Parser unable to reconcile "+eText.substring(ei)+"\nwith "+rawText.substring(ri));
    					return null;
    				}
    			}
    			while (ei<eText.length() && Character.isWhitespace(eText.charAt(ei))) {
					ei++;
				}
    			while (ri<rawText.length() && Character.isWhitespace(rawText.charAt(ri))) {
					ri++;
				}
    		}
    		if (ei<eText.length()) {
    			System.err.println("Parser unable to reconcile parse "+eText+"\nwith source "+rawText+"\nseems parse has extra characters!");
    			return null;
    		}
    		return new Position(start, ri-start);
    	} catch (Exception ex) {
  			System.err.println("Parser unable to reconcile parse "+eText+"\nwith source "+rawText+"\n"+ex);
    		return null;
    	}
    }

    /**
     * Try to match text against first and last non-blank chars of the raw text.
     * Ignores internal (eg symbols) entirely.
     * @return position indicating start and length relative to the raw text supplied, or null if the match failed.
     */  //NOT USED ANYMORE, we do mod symbols instead!  -AH
//    public static Position findMatchRough(String eText,String rawText) {
//        try {
//        	String eTrim = eText.trim();
//        	if (eTrim.length()==0) return null;
//        	char ca = eTrim.charAt(0);
//        	char cz = eTrim.charAt(eTrim.length()-1);
//
//        	int start = rawText.indexOf(ca);
//        	if (start==-1) return null;
//
//        	int end = rawText.lastIndexOf(cz)+1;
//        	if (end==0) return null;
//
//        	if (rawText.substring(end).trim().length()>0) return null;  //not a match
//        	System.err.println("Parser.findMatchRough, guessing length of parse request region, may cause problems");
//        	return new Position(start,end-start);
//        } catch (Exception ex) {
//            return null;
//        }
//    }

    /** disposes of this parser; by default, does nothing, but some implementations may need disposal */
    public void dispose() { }
}
