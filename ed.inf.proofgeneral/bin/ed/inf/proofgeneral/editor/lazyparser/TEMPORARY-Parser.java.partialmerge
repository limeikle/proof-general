/*
 *  $RCSfile: TEMPORARY-Parser.java.partialmerge,v $
 *
 *  Created on 09 Sep 2004 by Daniel Winterstein
 *  part of Proof General for Eclipse
 */
package ed.inf.proofgeneral.editor.lazyparser;
import java.util.Iterator;

import org.dom4j.CharacterData;
import org.dom4j.Element;
import org.dom4j.Node;
import org.eclipse.jface.text.BadLocationException;
import org.eclipse.jface.text.IRegion;
import org.eclipse.jface.text.Position;
import org.eclipse.jface.text.TypedPosition;

import ed.inf.proofgeneral.Constants;
import ed.inf.proofgeneral.ProofGeneralPlugin;
import ed.inf.proofgeneral.document.ContainerElement;
import ed.inf.proofgeneral.document.DocElement;
import ed.inf.proofgeneral.document.ProofScriptDocument;
import ed.inf.proofgeneral.editor.actions.PGMarkerMethods;
import ed.inf.proofgeneral.pgip.Fatality;
import ed.inf.proofgeneral.sessionmanager.PGIPSyntax;
import ed.inf.proofgeneral.sessionmanager.ScriptingException;
import ed.inf.proofgeneral.symbols.HTMLSymbols;
import ed.inf.utils.datastruct.StringManipulation;

/**
 * The base class for script parsers. Extend this class (or subclasses)
 * to create a new parser - then edit SessionManager to get your new parser used.
 * This base class provides some generic functionality for linking a parseresult with a document.
 * This job is made harder by:
 *
 * 1) The parseresult may mangle whitespace and linebreaks.
 * 2) The parseresult may mix elements whose xml markup is generated by the parser
 * (ie. normal proof script elements),
 * and elements whose xml markup appears in the text (ie. interface script elements).
 *
 * @author Daniel Winterstein
 */
public abstract class Parser {

	/**
	 *
	 */
	public static class ParsingInterruptedException extends Exception {
		public ParsingInterruptedException(String text) {
			super(text);
		}
	}

	/**
	 * Determines whether this parser is slow (and should not be allowed to block) or fast
	 * @return whether or not this parser is slow (true=slow)
	 */
	public abstract boolean isSlow();

	/** @return whether this parser can give the next command really quickly
	 *  (and thus doesn't need to be put in a separate thread, eg by SendCommandAction)
	 */ //added by -AH to fix bug where go-to-line doesn't work
  public boolean hasNextCommandFast(ProofScriptDocument doc, String type) {
  	if (!isSlow()) {
		return true;
	}
    int so = Math.max(doc.getProcessedOffset() + 1,0);
    DocElement e = doc.findNext(type,so);
    return (e!=null);
	}
	/** @return whether this parser can give the next command of type COMMAND really quickly
	 *  (and thus doesn't need to be put in a separate thread, eg by SendCommandAction)
	 */ //added by -AH to fix bug where go-to-line doesn't work
  public boolean hasNextCommandFast(ProofScriptDocument doc) {
  	return hasNextCommandFast(doc, PGIPSyntax.COMMAND);
	}

	/**
	 * The action that initiated the current/latest parse.
	 * Used with external parsers to co-ordinate the response.
	 * Should be set to null when the parse is finished.
	 */
	Object cause = null;
    /**
     * @param cause The action that initiated this parse. Used with external parsers to co-ordinate the response.
     */
    public void setCause(Object cause) {
        this.cause = cause;
    }

	public Parser(PGIPSyntax syntax) {
		this.syntax = syntax;
	}
	/**
	 * The syntax object to be used in parsing
	 */
	PGIPSyntax syntax;

    /**
     * Return a list of DocElements
     * @param text
     * @return
     * @throws ScriptingException
     */
    //public abstract List parse(String text) throws ScriptingException;

    /**
     * Parse document from offset for the given length, updating the document's parse tree.
     * @param doc
     * @param offset
     */
    public synchronized void parseDoc(ProofScriptDocument doc, int offset, int length)
    throws BadLocationException,ScriptingException,ParsingInterruptedException {
    	String text = doc.get(offset, length);
    	PGMarkerMethods.cleanMarkers(doc, offset,length); // NB: this removes *all* markers

     	Element parseResult = parseText(text,doc,offset);
    	linkParse(parseResult,doc,offset,text);
    }

    /**
      *	Returns the next command for sending out to the TP
      * @param doc
      * @return DocElement
      * @throws ParsingInterruptedException 
      */
    public synchronized DocElement findNextCommand(ProofScriptDocument doc)
    throws ScriptingException, ParsingInterruptedException {
    	return findNextCommand(doc, PGIPSyntax.COMMAND);
    }
    /**
   	 * Returns the next element of the specified type, for sending out to the TP
     * @param doc
     * @return DocElement
     * @throws ParsingInterruptedException 
     */
      public synchronized DocElement findNextCommand(ProofScriptDocument doc, String type)
      throws ScriptingException, ParsingInterruptedException {
          int so = Math.max(doc.getProcessedOffset()+1, 0);
          DocElement e = doc.findNext(type, so);
          if (e != null) {
			return e;
		}
          return findObject(type, doc, so);
      }
      public synchronized DocElement findNextCommandFast(ProofScriptDocument doc, String type) {
          int so = Math.max(doc.getProcessedOffset()+1, 0);
          DocElement e = doc.findNext(type, so);
          if (e != null) {
			return e;
		}
          return null;
      }

    public synchronized DocElement findObject(String type,ProofScriptDocument doc, int startOffset)
    throws ScriptingException, ParsingInterruptedException {
    	return findObject(type,"",doc,startOffset);
    }

    /** finds the next object, by following a programmed list of non-blank lines to jump;
     *  use strategy to add 1 line, then 3, then 12, then the whole shebang
     * @throws ParsingInterruptedException */
    public synchronized DocElement findObject(String type, String preLine,
				 ProofScriptDocument doc, int startOffset)
    throws ScriptingException, ParsingInterruptedException
		{
    	// DA Sep 06: FIXME: the strategy here (or in linkObject) is flawed because we can
    	// have valid commands which are prefixes of valid commands (e.g. constdefs).
    	// What should be done is to find two successive command beginnings
    	// (like in the Emacs code...).  Since the parsing efficiencies have been fixed
    	// in the current Isabelle CVS, I've added a preference to control whether
    	// this dodgy strategy is used or not.  Nonetheless, it might be desirable
    	// to re-activate this code because editing at the start of a long document
    	// causes long delays in reparsing.
    	int[] intervals = { 1, 3, 12, 36, 108, 432, -1 };
    	boolean useintervals =
    		ProofGeneralPlugin.getBooleanPref(Constants.PREF_USE_GATHERING_PARSER);
    	return findObject(type, preLine, doc, startOffset,
    			useintervals ? intervals : new int[] { -1 } );
		}


    /**
     * Parse ahead looking for objects
     * Returns null if it hits the end of file without finding anything
     * @param type
     * @param preLine
     * @param doc
     * @param startOffset
     * @param linesToAdd an array of the number of lines to add at a time
     * @return the discovered object matching specification
     * @throws ScriptingException
     * @throws ParsingInterruptedException
     */
    public synchronized DocElement findObject(String type, String preLine,
            					 ProofScriptDocument doc, int startOffset, int[] linesToAdd)
    throws ScriptingException, ParsingInterruptedException
    {
        IRegion r;
        String line = "";
        int endOffset = -1;
        int lineNo = -1;
        int offset = startOffset;
        int linesAdded = 0;
        try {
            lineNo = doc.getLineOfOffset(offset);
            do {
                r = doc.getLineInformation(lineNo);
                endOffset = r.getOffset() + r.getLength();
                if (endOffset <= offset) {
                    // startOffset is a line delimiter; move on to the next line
                    lineNo++;
                    continue;
                }
                line += doc.get(offset, endOffset-offset);   //TODO should use a stringbuffer instead...
                offset += endOffset-offset;
                if (!StringManipulation.isWhitespace(line)) {
					linesAdded++; // don't send empty lines
				}
                lineNo++;
            } while (linesToAdd[0]==-1 || linesAdded<linesToAdd[0]);
        } catch(BadLocationException ex) {
        	//reached end of file
        	if (linesAdded==0) {
				return null;
			}
        }
        Element parseResult;
        try {
        	parseResult = parseText(preLine+line, doc, startOffset);
        	//System.out.println("result of parse from "+startOffset+" (of "+(preLine+line).length()+" chars) is "+parseResult.elements().size()+" elements");
        	//if (parseResult.elements().size()>8 && startOffset>60) ...
        } catch (ScriptingException ex2) {
        	//doesn't usually throw Unparseable
        	if (ex2 instanceof UnparseableException) {
        		return findObject(type,preLine+line,doc,endOffset,dropFirstFromArray(linesToAdd));
        	} else {
				throw ex2;
			}
        }

        try {
        	linkParse(parseResult,doc,startOffset - preLine.length(),preLine+line);   //should be this, i think -AH
        	//linkParse(parseResult,doc,startOffset,preLine+line);
        } catch (UnparseableException x) {
        	// perhaps the unparseable bit is below our element?
        	DocElement e = doc.findNext(type,startOffset - preLine.length());
        	if (e != null) {
				return e;
			}
        	DocElement foundElt = null;
        	//System.out.println(General.makeDateString()+"  expanding parse starting at "+(startOffset-preLine.length())+", size "+(linesToAdd[0]));
        	foundElt = findObject(type,preLine+line,doc,endOffset, dropFirstFromArray(linesToAdd));
        	//System.out.println(General.makeDateString()+"  expanded parse starting at "+(startOffset-preLine.length())+", size "+(linesToAdd[0])+"; result "+(foundElt==null ? "null" : "FOUND"));
        	if (foundElt!=null) {
				return foundElt;
			}
        	//if we got null, we are at end of doc, and unparseable
        	throw x;
        }
        DocElement e = doc.findNext(type,startOffset - preLine.length());
        if (e != null) {
			return e;
		}
        try {
            int nextOffset = doc.getLineOffset(1+lineNo);
            return findObject(type,"",doc, nextOffset);
        } catch (BadLocationException ex) {
            throw new ScriptingException("Exception when looking for a command. "+ex.getMessage());
        }
    }


    /**
     * Removes the first item from an array, if it contains more than one element.
     * @param in the array to modify
	 * @return a new array, minus the first element of the given array
	 */
    // FIXME da: library function?  Do we need to make a new array here?
	private int[] dropFirstFromArray(int[] in) {
		int drop = (in.length > 1 ? 1 : 0);
		int[] out = new int[in.length - drop];

		for (int i = 0; i < out.length; i++) {
			 out[i] = in[i+drop];
		}
		return out;
	}

    /**
     * Parse the rest of the document from offset. Wrapper for parseDoc/4
     * @param doc
     * @param offset
     * @throws BadLocationException
     * @throws ScriptingException
     * @throws ParsingInterruptedException
     */
    public void parseDoc(ProofScriptDocument doc, int offset)
    throws BadLocationException,ScriptingException, ParsingInterruptedException {
    if (doc.getLockOffset() > offset) {
    	System.err.println("Warning:  Parser.parseDoc called to parse from "+offset+"; but buffer is locked to "+doc.getLockOffset());
    }
    if (doc.getProcessedOffset() > offset) {
    	System.err.println("Warning:  Parser.parseDoc called to parse from "+offset+"; but buffer is processed to "+doc.getProcessedOffset()+": parsing from processed point");
    	offset = doc.getProcessedOffset();
    }
    try {
    	if (offset<doc.getParseOffset()) {
      		doc.setEditOffset(offset); // throw away old parse information
      	}
     } catch (Exception e) {
      	System.err.println("Error setting offset in Parser.parseDoc: "+e);
      	e.printStackTrace();
     }
     	parseDoc(doc, offset, doc.getLength()-offset);
    }

    /**
     * Parse the text, returning a <parseresult> element, containing the parse results (elements and/or errors).
     * Use in preference to dumbParseText where doc is known, as it allows the parser to use context.
     * The default implementation just calls dumbParseText
     * @param text
     * @return the parsed element
     * @throws ScriptingException
     */
    public Element parseText(String text,ProofScriptDocument doc,int offset) throws ScriptingException, ParsingInterruptedException {
    	return dumbParseText(text);
    }
    /**
     * Parse text, ignoring issues regarding document partitions.
     * For this reason, you should use parseText in preference where possible.
     * @param text
     * @return parse result
     * @throws ScriptingException
     */
    public abstract Element dumbParseText(String text) throws ScriptingException, ParsingInterruptedException;

    /**
     * Exception to signal that some text was unparseable
     */
    public static class UnparseableException extends ScriptingException {

        UnparseableException(String msg) {
            super(msg);
        }
    }

    /**
     * Convert the parse result into doc elements
     * @param parseResult (containing a list of Elements)
     * @param doc the document to notify of our events
     * @param startOffset the starting offset
     * @throws UnparseableException if the parse result was not good.
     */
    public void linkParse(Element parseResult, ProofScriptDocument doc,
            				int startOffset, String rawText)
    throws UnparseableException {
        try {
            linkParse(parseResult.elements().listIterator(),doc,startOffset,rawText);
        } catch (UnparseableException ex) {
            try {
            	// da: added +1 in three places below, seemed to be OBO.  Doesn't stop
            	// assertion failures, though, perhaps these are due to non-changes
            	// in document?
                doc.fireParseTreeChangedEvent(startOffset,
                		(doc.getParseOffset()>startOffset ? doc.getParseOffset()-startOffset+1 : 0));
            } catch (Exception ex2) { ex2.printStackTrace(); }
            throw ex;
        }
        if (doc.getParseOffset()<=startOffset) {
        	//we've done nothing, probably at end of document
        	return;
        }
        try {
            doc.fireParseTreeChangedEvent(startOffset,doc.getParseOffset()-startOffset+1);
        } catch (Exception ex) {
        	//don't worry about this out of debug mode
        	//(it seems pretty common when starting without causing any problems), eg
        	/*
start-offset:0 offset:22 doc-length:54
org.eclipse.jface.text.Assert$AssertionFailedException: Assertion failed:
        at org.eclipse.jface.text.Assert.isTrue(Assert.java:189)
        at org.eclipse.jface.text.Assert.isTrue(Assert.java:174)
        at org.eclipse.ui.internal.texteditor.quickdiff.compare.equivalence.DocEquivalenceComparator.<init>(DocEquivalenceComparator.java:47)
        at org.eclipse.ui.internal.texteditor.quickdiff.DocumentLineDiffer.handleChanged(DocumentLineDiffer.java:916)
        at org.eclipse.ui.internal.texteditor.quickdiff.DocumentLineDiffer.documentChanged(DocumentLineDiffer.java:762)
        at org.eclipse.jface.text.AbstractDocument.doFireDocumentChanged2(AbstractDocument.java:729)
        at org.eclipse.jface.text.AbstractDocument.doFireDocumentChanged(AbstractDocument.java:692)
        at org.eclipse.jface.text.AbstractDocument.doFireDocumentChanged(AbstractDocument.java:677)
        at ed.inf.proofgeneral.editor.ProofScriptDocument.fireParseTreeChangedEvent(ProofScriptDocument.java:153)
        at ed.inf.proofgeneral.editor.lazyparser.Parser.linkParse(Parser.java:404)
        at ed.inf.proofgeneral.editor.lazyparser.Parser.findObject(Parser.java:235)
        at ed.inf.proofgeneral.editor.lazyparser.Parser.findObject(Parser.java:177)
        at ed.inf.proofgeneral.editor.lazyparser.Parser.findObject(Parser.java:166)
        at ed.inf.proofgeneral.editor.lazyparser.Parser.findNextCommand(Parser.java:127)
        at ed.inf.proofgeneral.editor.actions.SendCommandAction$BgParse.run(SendCommandAction.java:182)
        at ed.inf.heneveld.utils.process.ThreadPool$PooledThread.run(ThreadPool.java:172)
        	 */
        	if (ProofGeneralPlugin.debug(this)) {
        		System.err.print("Exception firing ParseTreeChangedEvent ");
        		System.err.println( "start-offset:"+ startOffset + " parse offset:"+doc.getParseOffset() +
        				" length:" + (doc.getParseOffset()-startOffset+1) +  " doc-length:"+doc.getLength() );
        		// ex.printStackTrace()
        		/*
        		try {
        			doc.fireParseTreeChangedEvent(Math.max(0,startOffset),
        					Math.min(doc.getLength()-Math.max(0,startOffset),
        							(doc.getParseOffset()>startOffset ? doc.getParseOffset()-startOffset : 0)));
        		} catch (Exception ignore) {}
        		*/
        	}
        }
    }

    /**
     * Create a container element (presumably to follow just after an opentheorem)
     * for a proof. Add it to the proof parse tree and set it as the new open element.
     * @param doc
     * @param startOffset - cEnd+1
     */
    void createProofElement(ProofScriptDocument doc, int startOffset) {
    	createOpenElement(doc, startOffset, PGIPSyntax.PROOF_CONTAINER);
    }

    /**
     * Create a container element for any types.
     * Add it to the proof parse tree and set it as the new open element.
     * @param doc
     * @param startOffset - cEnd+1
     * @param type - the name of the elemnt in the tree
     * @param pgiptype - the PGIP open-type which corresponds to this container, or null if none.
     */
    void createOpenElement(ProofScriptDocument doc, int startOffset, String type, String pgiptype) {
      ContainerElement pf = new ContainerElement(type, doc,pgiptype);
      pf.setPosition(new TypedPosition(startOffset, 0, type));
      doc.getOpenElement().add(pf);
      pf.open = true;
      doc.setOpenElement(pf);
    }

    /**
     * Recursive method that does the work for linkParse, linking elements into the
     * document and creating error markers for parse errors and warnings.
     */
    void linkParse(Iterator nodeIterator, ProofScriptDocument doc,
			int startOffset, String rawText) throws UnparseableException {
    	int offset = startOffset;
        String eText;
        DocElement parent = doc.getOpenElement();
        UnparseableException parseError = null;
        //cache fatal parsing errors until the end (since they usually only occur at the end, and we can take useful information before it)
        for (; nodeIterator.hasNext();) {
            Node node = (Node) nodeIterator.next();

            // handle parsing errors: these are different to normal error messages because they are embedded
            // in the parseresult message and by convention precede an <unparseable> sequence.
            // So the main event loop does not add markers for parse errors.  That's just
            // as well because it allows us to calculate the regions affected here, and the messages
            // (from Isabelle, as of Jan 07) do not include location information themselves.
            // We could consider flattening the structure when Isabelle gets better at reporting
            // locations, but this will need changes in the Broker too. - da.
            if (node.getName()!=null && syntax.subType(node.getName(),PGIPSyntax.ERRORRESPONSE) ) {
            	assert node instanceof Element : "Bad weirdness: Received an error outside of an element.";
            Fatality fatality = Fatality.fromString(((Element)node).attributeValue("fatality"));
            // The next two cases could maybe be combined.
            if (!fatality.commandFailed()) { // set a problem marker and carry on. should be only case, really.
            	try {
            		// FIXME NB: addMarker in PGMarkerMethods already uses a runnable, although its scope
            		// might be widened.
            		String msg = parseError != null ? parseError.getMessage() : ((Element) node).getStringValue();
            		int errorOffset = offset;
            		try {
            			while (Character.isWhitespace(doc.getChar(errorOffset))) {
            				errorOffset++;
            			}
            		} catch (Exception e) { // nothing
            		}
            		PGMarkerMethods.addProblemMarker(doc,
            				new Position(errorOffset,node.getText().length()), // FIXME: use location if set
            				-1,
            				"Parse problem: "+msg.replaceFirst("\n.*","..."),
            				msg,
            				fatality.markerSeverity());
            		continue;
            	} catch (Exception x) {
            		x.printStackTrace();
            		throw new UnparseableException(node.getStringValue());
            	}
            	// A fatal error usually terminates the parse with the rest being unparseable.
            } else if (fatality == Fatality.FATAL) {
            	if (parseError==null) {
            		parseError = new UnparseableException(node.getStringValue());
            	}
            	//note we assume the result comes as
            	//<errorresponse .../> .... <unparseable .../> ....
            	//and we keep loading nodes after errors, except for the 'unparseable' bit
            	//that allows us to set any valid parse info returned
            	if (syntax.subType(node.getName(),PGIPSyntax.UNPARSEABLE)) {
            		//set firstErrorOffset if we are element "unparseable" and we get here
            		if (parseError.errorDoc==null) {
            			parseError.errorDoc = doc;
            			parseError.errorOffset = offset;
            			//we've got to skip whitespace also
            			try {
            				while (Character.isWhitespace(doc.getChar(parseError.errorOffset))) {
            					parseError.errorOffset++;
            				}
            			} catch (Exception e) {}
            			// da: added next line to add a marker.
            			// FIXME: this probably shouldn't be done if we haven't parsed the complete rest-of-document,
            			// using the "gathering" strategy, since we'll see a succession of markers added!!
            			// Probably simply disable this in this code (and hope we never need "gathering" again).
            			String msg = parseError.getMessage();
            			PGMarkerMethods.addProblemMarker(doc,
            					new Position(parseError.errorOffset,node.getText().length()),  // FIXME: use location if set
            					-1, "Parse error: "+msg.replaceFirst("\n.*","..."),
            					msg,
            					fatality.markerSeverity());
            		}
            		throw parseError;  //throw this when we get to the 'unparseable' node
            		//(but use the text from the 'errorResponse' node)
            	}
            }
            } else {
            	Position p=null;
            	if (node instanceof Element) {
                	//  internal commands are wrapped in XML in the document.
            		// FIXME da: I think we should remove this. Should check
            		// first that this isn't used in startup.
            		p = findMatch((Element)node,rawText);
            		if (p!=null) {
            			eText = rawText.substring(p.offset,p.offset+p.length);
            			System.err.println("DEBUG NOTE: Found a match with XML in document!");
            		} else {
						eText = node.getText();
					}
            	} else {
					eText = node.getText();
				}
            	// TODO da: do not trip here, but rather match exactly.
            	// We should skip spaces when we add markers instead.
            	eText = StringManipulation.trim(eText); // some protection against \r\n = \n wierdness. Also stops markers being positioned on earlier (empty) lines.
            	//TODO we should take the position as the next in the doc after fParseOffset, and this below should just be a check; but this is working
            	int gap = rawText.indexOf(eText);
            	// da: if the text was found, check that only whitespace was given
            	// first.
            	// debug:
            	//if (gap > -1) {
            	//	System.out.println("Found match for element "+node.getName()+" with gap " + gap);
            	//	if (!rawText.substring(0, gap).matches("[ \\n]+")) { // FIXME regexp
            	//		// Match was later in text, don't take it.
            	//		gap = -1;
            	//	}
            	//}
            	// attempt to correct for whitespace and linebreak issues.
            	Position truePosn = null; // lots of potential for out-by-1-or-2 errors
            	if (gap==-1) {
//            		 FIXME da: very buggy, only matches part of element text, allows spaces anywhere!
            		truePosn = findMatch(eText,rawText);
            		if (truePosn != null) {
						gap = truePosn.offset;
					} else {
            			//added by AH to try to fix symbol discrepancies ("Rough" is a hack, but this sounds pretty good)
            			truePosn = findMatchModSymbols(eText,rawText);
            			if (truePosn != null) {
							gap = truePosn.offset;
						}
            		}
            	}

            	if (gap!=-1) {
            		offset += gap;
            		rawText = rawText.substring(gap);
            	} else {
            		//if (ProofGeneralPlugin.debug())
            		System.err.println("Possible Error: linkParse found a gap of -1 in element "+eText);
            		// leave offset alone and hope for the best
            	}
            	if (node instanceof CharacterData) {
            		parent.addText(node.getText());
            	} else {
            		// ignore empty elements
            		if (StringManipulation.isWhitespace(eText)
            				|| PGIPSyntax.WHITESPACE.equals(node.getName())) {
            			continue;  //if (!node.hasContent()) continue;
            		}

            		if (p!=null) {
            			DocElement docE = linkElement((Element) node,doc,offset,rawText,false,p.length);
            			docE.rawText = eText; // avoid setting this where possible, because it will probably cause bugs
            		} else {
            			int length = truePosn==null? -1 : truePosn.length;
            			DocElement docE = linkElement((Element) node,doc,offset,rawText,false,length);
            			eText = StringManipulation.trim(docE.getText());
            		}
            	}
            	offset += truePosn!=null? truePosn.length : eText.length();
            	// da: we can get here without success and then try to take a substring on a shorter
            	// string, throwing IndexOutOfBoundsException.  I've patched but the
            	// parsing stuff here really needs a good makeover!
            	if (truePosn != null) {
            		assert truePosn.length <= rawText.length() : "Parser identified/lost too much text";
            		rawText = rawText.substring(truePosn.length); // good case
            	} else {
            		if (eText.length()<rawText.length()) {
            			rawText = rawText.substring(eText.length());
            		} else {
            			rawText = "";
            		}
            	}
            }
        }
        if (parseError!=null) {
			//we come here if there were no elements
        	throw parseError;
		}
    }
    /**
     * Create a DocElement (with typed position) from an element
     * and add it to the current open container of the document.
     *
     * Attaches comments to elements, where possible, for use as tooltips/hover help.
     *
     * This implements part of the spec for how proof scripts are set out
     * ASSUMPTION: a theorem is followed by a proof
     *
     * @param e the element to convert
     * @param doc			the document to notify
     * @param offset		the offset of the element
     * @param rawText		the text of the element
     * @param fireEvents	should be true, unless the calling function intends to fire
     * 						a bulk event (eg. it is doing a big parse, and doesn't want to
     * 						slow the system down with lots of little events)
     * @param length		Set to -1 if the length is unknown
     * @return the converted Element
     */
    public DocElement linkElement(Element e, ProofScriptDocument doc, int offset,
            						String rawText,boolean fireEvents, int length)
    throws UnparseableException {
        DocElement de;
        String name = e.getName();

        ContainerElement addPt = doc.getOpenElement();

        if (syntax.subType(name, PGIPSyntax.DOCCOMMENT)) { // FIXME da: Isabelle-specific
        	if (e.getStringValue().startsWith("subsection")) {
        		//close the previous open element when we get here
            if (addPt != doc.getRootElement()) {
              doc.closeOpenElement();
              addPt = doc.getOpenElement();
            }
        	}
        }

        DocElement previous = addPt.getLastElement();

        TypedPosition posn = new TypedPosition(offset,0,name);
        if (e.elements().size()!=0) {
			de = new ContainerElement(name,doc,null);
		} else {
        	String containerType = null;
        	if (syntax.subType(name,PGIPSyntax.OPENGOAL)) {
				containerType = PGIPSyntax.PROOF_CONTAINER;
			} else if ((syntax.subType(name, PGIPSyntax.DOCCOMMENT)) &&
							(e.getStringValue().startsWith("subsection"))) {
				containerType = PGIPSyntax.SECTION_CONTAINER;
			}
        	if (containerType!=null) {
        		//these types get a new container
        		ContainerElement ce = ContainerElement.containerForElement(e, doc);

        		if (ce != null) {
        			//HACK! check we don't already have one similar, if we do we may have to remove it
        			DocElement le = addPt.getLastElement(), lle = le;
        			while (le!=null && le instanceof ContainerElement) {
        				lle = le;
        				le = ((ContainerElement)le).getLastElement();
        			}
        			if (lle.getPosition().offset+lle.getPosition().length >= posn.offset+posn.length) {
        				// da: I see this quite often.  Add some more debug info
        				System.err.println("may already have container in tree!!");
        				if (ProofGeneralPlugin.debug(this)) {
        					System.err.println("Document element being added is: \n" + e.toString());
        					System.err.println("Container element being added is: " + ce.toString());
        					System.err.println("Container element already there is: " + le.toString());
        				}
        			}
        			addPt.add(ce);
        			doc.setOpenElement(ce);
        			ce.open = true;
        			// TODO da: it's supposed to be possible to have positions move with the document,
        			// can we do this?  Otherwise we could use a lighterweight version of Position, I think.
        			ce.setPosition(new TypedPosition(offset, 0, containerType));
        			//will need length eventually... should get it automatically
        			addPt = doc.getOpenElement();
        		}
        	}
        	de = new DocElement(name,doc);
        }

        if (de instanceof ContainerElement) {
        	doc.setOpenElement((ContainerElement)de);
        	// recursive call to linkParse
        	linkParse(e.nodeIterator(), doc, offset, rawText);
       		doc.closeOpenElement();
        } else {
            // FIXME da: why .trim? Better if has verbatim text so can reconstruct doc,
        	// even take this element structure as model
        	de.setText(e.getText().trim());
        }

        de.setPosition(posn);
        de.setAttributes(e.attributes());
        addPt.add(de);

        // give this element some length
        if (length==-1) {
            posn.length = de.getText().length();
        } else {
        	posn.length = length;
        }
        int cEnd = offset + posn.length;
        ContainerElement ce = addPt;
        while (ce!=null) {
        	//set container length on all nodes up the hierarchy
          ce.getPosition().length = cEnd - ce.getPosition().offset;
          ce = (ContainerElement)ce.getParent();
        }

        if (syntax.subType(name,PGIPSyntax.OPENGOAL)) {
        	//do this above instead
            // create a proof element to contain the proof
            // starting just after the opentheorem command
            //createProofElement(doc,cEnd+1);
        } else
        if (syntax.subType(name,PGIPSyntax.CLOSEGOAL)) {
        	//this needs to close the open element, once we have beenadded
            if (!syntax.subType(addPt.getType(),
            		//PGIPSyntax.PROOF
            		PGIPSyntax.PROOF_CONTAINER
            		)) {
                throw new UnparseableException("A close theorem command appears without a corresponding open theorem");
            }
            if (addPt != doc.getRootElement()) {
                doc.closeOpenElement();
            } else { // tried to close the root element
                System.err.println("syntax error in script - too many closing elements"); // TODO signal the user
            }
        }

        // if the previous element was a comment, and this one is not a comment
        // then create a tooltip for our new element.
        if (previous !=null && syntax.subType(previous.getType(),PGIPSyntax.COMMENT)
                //&& !syntax.subType(previous.getType(),PGIPSyntax.FORMALCOMMENT)
                && !syntax.subType(name,PGIPSyntax.COMMENT)) {
            de.setTooltip(previous.getText());
        }

        doc.createMarker(de); // must be called after de.setTooltip()

        try {
            if (fireEvents) {
				doc.fireParseTreeChangedEvent(offset,cEnd-offset);
			}
            doc.setParseOffset(cEnd);
        } catch (Exception ex) {
            ex.printStackTrace();
        }
        if (ProofGeneralPlugin.debug(this)) { //DEBUG-TEST-CODE
            try {
                String deText = de.getText();
                String docText = doc.get(de.getPosition().offset,de.getPosition().length);
                assert findMatch(deText,docText) != null : "Mismatch in parser: "+deText+" != "+docText;
            } catch (Exception x) {x.printStackTrace();}
        } //END-DEBUG
        return de;
    }

    /**
     * Try to match the xml of an element against the beginning of the "raw" text from the editor.
     * Ignores white-space and quote marks, since these can be changed by xml parsers.
     * ASSUMPTION: This will <b>not</b> spot that &lt;dummy&gt;&lt;/dummy&gt; = &lt;dummy/&gt;;
     *  I am assuming this kind of syntax switch won't occur.
     * @return position indicating start and length relative to the raw text supplied, or null if the match failed.
     */
    public static Position findMatch(Element e,String rawText) {
    	// FIXME da: crummy code again.  Shouldn't use exceptions as matter of course.
    	try {
            String name = e.getName();
            String asXML = e.asXML();
            int start = rawText.indexOf(name)-1;
            if (start<0) {
				return null;
			}
            int j=start;
            for(int i=0; i<asXML.length(); i++) {
                char xc = asXML.charAt(i);
                if (ignore.indexOf(xc) != -1) {
                	continue;
                }
                while(true) {
                    char rc = rawText.charAt(j);
                    if (ignore.indexOf(rc)!= -1) {
                        j++; continue;
                    }
                    if (xc==rc) {
                        j++;
                        break;
                    }
                    return null;
                }
            }
            return new Position(start,j-start);
        } catch (Exception ex) {
            return null;
        }
    }
    static final String ignore =" \r\n\t";  //don't think we should be ignoring ' and "  -AH


    /**
     * Try to match text against the beginning of the raw text, ignoring whitespace and \r\n / \n differences.
     * @return position indicating start and length relative to the raw text supplied, or null if the match failed.
     */
     // da: FIXME: pretty sloppy stuff.  Use of exceptions isn't great,
     // (possibly odd return values when text prefix matches at end of string?)
     // Also, this matches "h e l l o" against "hello" which we don't want.
    public static Position findMatch(String eText,String rawText) {
    	assert !(eText.equals("") || rawText.equals("")): "Empty input";
        try {
        int start=-1; 
        int j=0;
        for(int i=0; i<eText.length(); i++) {
            char ec = eText.charAt(i);
            if (ignore.indexOf(ec) != -1) {
            	continue;
            }
            while(true) {
                char rc = rawText.charAt(j);
                if (ignore.indexOf(rc)!= -1) {
                    j++; continue;
                }
                if (ec==rc) {
                    if (start==-1) {
						start = j;
					}
                    j++;
                    break;
                }
                return null;
            }
        }
        if (start==-1) {
			return null;
		}
        return new Position(start,j-start);
        } catch (Exception ex) {
            return null;
        }
    }

    public static Position findMatchModSymbols(String eText, String rawText) {
    	try {
    		int ei=0, ri=0;
    		while (ei<eText.length() && Character.isWhitespace(eText.charAt(ei))) {
				ei++;
			}
    		while (ri<rawText.length() && Character.isWhitespace(rawText.charAt(ri))) {
				ri++;
			}
    		int start=ri;
    		while (ei<eText.length() && ri<rawText.length()) {
    			if (eText.charAt(ei)==rawText.charAt(ri)) {
    				ei++;
    				ri++;
    			} else {
    				int[] mis = prover.getSymbols().checkStringsStartSameSymbol(eText, ei, rawText, ri);
    				if (mis!=null) {
    					ei += mis[0];
    					ri += mis[1];
    				} else {
    					System.err.println("Parser unable to reconcile "+eText.substring(ei)+"\nwith "+rawText.substring(ri));
    					return null;
    				}
    			}
    			while (ei<eText.length() && Character.isWhitespace(eText.charAt(ei))) {
					ei++;
				}
    			while (ri<rawText.length() && Character.isWhitespace(rawText.charAt(ri))) {
					ri++;
				}
    		}
    		if (ei<eText.length()) {
    			System.err.println("Parser unable to reconcile parse "+eText+"\nwith source "+rawText+"\nseems parse has extra characters!");
    			return null;
    		}
    		return new Position(start, ri-start);
    	} catch (Exception ex) {
  			System.err.println("Parser unable to reconcile parse "+eText+"\nwith source "+rawText+"\n"+ex);
    		return null;
    	}
    }

    /**
     * Try to match text against first and last non-blank chars of the raw text.
     * Ignores internal (eg symbols) entirely.
     * @return position indicating start and length relative to the raw text supplied, or null if the match failed.
     */  //NOT USED ANYMORE, we do mod symbols instead!  -AH
    public static Position findMatchRough(String eText,String rawText) {
        try {
        	String eTrim = eText.trim();
        	if (eTrim.length()==0) {
				return null;
			}
        	char ca = eTrim.charAt(0);
        	char cz = eTrim.charAt(eTrim.length()-1);

        	int start = rawText.indexOf(ca);
        	if (start==-1) {
				return null;
			}

        	int end = rawText.lastIndexOf(cz)+1;
        	if (end==0) {
				return null;
			}

        	if (rawText.substring(end).trim().length()>0) {
				return null;  //not a match
			}
        	System.err.println("Parser.findMatchRough, guessing length of parse request region, may cause problems");
        	return new Position(start,end-start);
        } catch (Exception ex) {
            return null;
        }
    }

    /** disposes of this parser; by default, does nothing, but some implementations may need disposal */
    public void dispose() { }


}
