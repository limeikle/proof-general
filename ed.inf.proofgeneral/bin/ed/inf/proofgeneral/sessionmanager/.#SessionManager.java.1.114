/*
 * Created on 16-Apr-2004
 *
 */
package ed.inf.proofgeneral.sessionmanager;

/**
 * The "session manager" (aka "Proof Script Manager") will
 - start, maintain & close process based sessions with a command line prover
 - pass commands to the prover
 - receive responses from the prover & fire events (to which listeners can be attached)
 - maintain a command history & message log
 
 Session managers must be given the details of the prover they will talk to.
 
 * @author Daniel Winterstein
 *
 */


import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.StringReader;
import java.net.Socket;
import java.util.ArrayList;
import java.util.EmptyStackException;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Stack;
import java.util.Timer;
import java.util.TimerTask;

import org.dom4j.Document;
import org.dom4j.DocumentException;
import org.dom4j.Element;
import org.dom4j.io.SAXReader;
import org.eclipse.jface.preference.IPreferenceStore;
import org.eclipse.jface.util.IPropertyChangeListener;
import org.eclipse.jface.util.PropertyChangeEvent;

import ed.inf.heneveld.utils.General;
import ed.inf.heneveld.utils.MutableInteger;
import ed.inf.heneveld.utils.MutableObject;
import ed.inf.heneveld.utils.process.PooledRunnable;
import ed.inf.heneveld.utils.process.RunnableWithParams;
import ed.inf.heneveld.utils.process.ThreadPool;
import ed.inf.proofgeneral.CommandProcessor;
import ed.inf.proofgeneral.Constants;
import ed.inf.proofgeneral.ErrorUI;
import ed.inf.proofgeneral.ProofGeneralPlugin;
import ed.inf.proofgeneral.SetPrefAction;
import ed.inf.proofgeneral.editor.IProofScriptDocument;
import ed.inf.proofgeneral.editor.IProofScriptEditor;
import ed.inf.proofgeneral.editor.PGTextHover;
import ed.inf.proofgeneral.editor.ProofScriptDocument;
import ed.inf.proofgeneral.editor.actions.InterruptAction;
import ed.inf.proofgeneral.editor.actions.PGAction;
import ed.inf.proofgeneral.editor.actions.WaitReadyAction;
import ed.inf.proofgeneral.editor.lazyparser.ExternalLazyParser;
import ed.inf.proofgeneral.editor.lazyparser.MixedParser;
import ed.inf.proofgeneral.editor.lazyparser.PGIPParseResult;
import ed.inf.proofgeneral.editor.lazyparser.Parser;
import ed.inf.proofgeneral.outputviewer.CurrentStateView;
import ed.inf.proofgeneral.outputviewer.ErrorView;
import ed.inf.proofgeneral.outputviewer.LatestOutputView;
import ed.inf.proofgeneral.outputviewer.SessionLogView;
import ed.inf.proofgeneral.pgip2html.Converter;
import ed.inf.proofgeneral.sessionmanager.events.ActiveScriptChangedEvent;
import ed.inf.proofgeneral.sessionmanager.events.CommandCausedErrorEvent;
import ed.inf.proofgeneral.sessionmanager.events.CommandProcessed;
import ed.inf.proofgeneral.sessionmanager.events.CommandSucceeded;
import ed.inf.proofgeneral.sessionmanager.events.InternalEvent;
import ed.inf.proofgeneral.sessionmanager.events.PGCommandReceived;
import ed.inf.proofgeneral.sessionmanager.events.PGIPBogus;
import ed.inf.proofgeneral.sessionmanager.events.PGIPError;
import ed.inf.proofgeneral.sessionmanager.events.PGIPEvent;
import ed.inf.proofgeneral.sessionmanager.events.PGIPIncoming;
import ed.inf.proofgeneral.sessionmanager.events.PGIPOutgoing;
import ed.inf.proofgeneral.sessionmanager.events.PGIPReady;
import ed.inf.proofgeneral.sessionmanager.events.PGIPShutdown;
import ed.inf.proofgeneral.symbols.HTMLSymbols;
import ed.inf.winterstein.methods.Fn;
import ed.inf.winterstein.methods.LimitedMap;
import ed.inf.winterstein.methods.LimitedStack;
import ed.inf.winterstein.methods.Methods;
import ed.inf.winterstein.methods.Methods.Tree;

public class SessionManager 
implements PGIPListener,IPropertyChangeListener,PGEventMaker {
	
	/**
	 * count of unnamed objects, used by makeName
	 */
	public static int unnamed = 1;
	/**
	 * Supply unique names for unnamed objects (at present, only opengoals)
	 * @return
	 */
	public static String makeName() {
		String name = "unnamed" + Integer.toString(unnamed);
		unnamed++;
		return name;
	}
	
	public ProverInfo proverInfo;
	public PGTextHover hoverHelp;
	
	//null constructor, callers should also call init(name) -AH
	public SessionManager() {}
	
	public SessionManager(String proverName) {
		init(proverName);
	}
	//made this a separate function because we might want to set other vars before calling this -AH
	public void init(String proverName) {
		// register for preference change events
		//ProofGeneralPlugin.getDefault().getPreferenceStore().addPropertyChangeListener(this);		
		ProofGeneralPlugin.getStaticPreferenceStore().addPropertyChangeListener(this);
		dflt = this;
		proverInfo = new ProverInfo(proverName);
		proverState = new ProverState(this, proverInfo.syntax);
		// listen to its own events
		addListener(this);
		synchronized (allSessionManagerListeners) {
			ProofGeneralPlugin.getDefault().setSessionManager(this);
			Iterator li = allSessionManagerListeners.iterator();
			while (li.hasNext()) {
				addListener((PGIPListener)li.next());
			}
		}
		hoverHelp = new PGTextHover(this);
		qUpdater = new QueueUpdater();
		// set up command processing
		CommandProcessor.link2sessionManager(this);
		try {
			startSession();
		} catch (Exception e) { 
			//			e.printStackTrace();
			firePGIPEvent(new PGIPError(this, Methods.lineEnd("Could not start a scripting session!")
					+ e.getLocalizedMessage() ));
		}

		// DONE --  should get a list of viewers somehow (use addAllSM...)
		// DONE -- sometimes none of these are created yet -- have to try on SM creation and VIEW creation
//		if (SessionLogView.getDefault() != null) {
//			addListener(SessionLogView.getDefault());
//			SessionLogView.getDefault().connected = true;
//		}
//		if (ErrorView.isCreated()) {
//			addListener(ErrorView.getDefault());
//			ErrorView.getDefault().connected = true;
//		}
//		if (LatestOutputView.isCreated()) {
//			addListener(LatestOutputView.getDefault());
//			LatestOutputView.getDefault().connected = true;
//		}
//		if (CurrentStateView.getDefault() != null) {
//			addListener(CurrentStateView.getDefault());
//			CurrentStateView.getDefault().connected = true;
//		}
		//this is mirrored in OutputView(), to protect against odd starting orders
	}

	/**
	 * Not sure that thi should ever be called. 
	 @see ed.inf.proofgeneral.sessionmanager.PGEventMaker#dispose()
	 */
	public void dispose() {
		// as a listener
		for(Iterator i = talkers.iterator(); i.hasNext();) {
			try {((PGEventMaker)i.next()).removeListener(this);}
			catch (Exception x) {}	        
		} 
		//talkers=null;
		// as a talker
		for(Iterator i = fPGIPListeners.iterator(); i.hasNext();) {
			try {((PGIPListener)i.next()).removeTalker(this);}
			catch (Exception x) {}	        	        
		}
		ProofGeneralPlugin.getStaticPreferenceStore()
		.removePropertyChangeListener(this);	    
	}	
	
	public String pgipClass = "pa"; // this is a proof assistant
	public String pgipId= "PG-Eclipse"; //
	public String pgipVersion = "lite 0.9";
	public int currentSeqnNo; // counts upwards in packageCommand			
	
	
	protected Process process = null;
	protected Socket socket = null;
	protected BufferedWriter writer = null;  //TODO shouldn't be public, just for debugging	
	protected StreamGobbler tpOutputGobbler = null;
	protected StreamGobbler tpErrorGobbler = null;            //-AH
	public ProverState proverState;
	
	/**
	 * Initiate a session (opening sockets, launching commands, etc. as necc)
	 * @throws IOException
	 */
	public void startSession() throws IOException, ScriptingException {
		int to = ProofGeneralPlugin.getIntegerPref(Constants.PREF_TIME_OUT);
		if (to>0) setTimeout(to,true);
		incompleteOutput = new StringBuffer(""); // reset anything left-over
		//		backgroundThread = false;    //changed so this isn't set here... should be set by default, and if changed, changer should revert this back (need true for standalone) -AH 
		logging = true;
		currentSeqnNo = 0;		
		privateListener = null;  //clear this
		if (proverInfo.getBoolean("ready messages")) startUpBumpfFlag = true; // put in some simple error-correcting for initial non-xml output
		
		
		if (proverInfo.getBoolean("Use Sockets")) {
			String hostName = proverInfo.getString("Host Address");
			int port = Integer.parseInt( proverInfo.getString("Port") );
			startSocketSession(hostName,port);
		} else {
			startProcessSession();
		}
		firePGIPEvent(new PGIPEvent(this,"Scripting session active.", null));
		killQueue("New Session");
		proverState.setBusy(false); // prover is not busy on start up
		setActiveScript(null,null);
		String STARTUP_SCRIPT  = proverInfo.getString("Startup Script");
		if (STARTUP_SCRIPT != null && !STARTUP_SCRIPT.equals("")) {
			String[] ss = STARTUP_SCRIPT.split(Methods.LINEEND);
			for(int i=0; i<ss.length; i++) {
				DocElement command = new DocElement(PGIPSyntax.SPURIOUSCOMMAND,null);
				command.setText(ss[i]);
				queueCommand(command);
			}
		}		
		try {
			setTPPrefs();
		} catch (ScriptingException x) {
			ErrorUI.getDefault().signalWarning(x);
		}
		proverState.setState(ProverState.TOP_LEVEL);
		currentSeqnNo = 1;
	}
	
	/**
	 * Send non-default config prefs out to the prover
	 *
	 */
	protected void setTPPrefs() throws ScriptingException {
		IPreferenceStore pStore = ProofGeneralPlugin.getStaticPreferenceStore();
		try {
			for(Iterator i = proverInfo.getConfigPrefs().iterator(); i.hasNext();) {
				String pName = (String)i.next();
				Object value = pStore.getString(pName);
				if (value.equals(pStore.getDefaultString(pName))) continue;
				SetPrefAction setAction = new SetPrefAction(this,pName,value);
				setAction.run();
			}
		} catch (Exception e) {
			throw new ScriptingException(e.getMessage());
		}
	}
	
	protected void startProcessSession () throws IOException {
		// create a process & streams
		//String LAUNCH_COMMAND = proverInfo.getString("Start Command");
		try {
			firePGIPEvent(new PGIPEvent(this,"Attempting to start a scripting session.", null));
			if (ProofGeneralPlugin.isEclipseMode())
				 WaitReadyAction.getDefault().start("Prover Not Started", 
					"The prover failed to send a ready message after 10s. "+
					"The path or options for the prover start command is probably wrong. "+
					"Try editting them in the Proof General preferences and restarting the prover. "+
					"For isabelle, make sure to pass the -I and -X options. "+
					"(It is unlikely that any commands will work until you fix this problem.)", 10*1000, this);
			synchronized (this) {
				process = Runtime.getRuntime().exec(
						proverInfo.getLaunchCommand(), null, proverInfo.getProverCwd());
			}
			BufferedReader reader = new BufferedReader(new InputStreamReader(
					process.getInputStream() 
			));
			
			//System.out.println("starting process "+process);
			
			tpOutputGobbler = new StreamGobbler("OutputStream", reader, this, true);
			tpOutputGobbler.setDaemon(true);
			tpOutputGobbler.start();
			
			//added error gobbler -- useful if Isabelle displays an error  --AH 2004-09-10
			reader = new BufferedReader(new InputStreamReader(
					process.getErrorStream() 
			));
			tpErrorGobbler = new StreamGobbler("ErrorStream", reader, this, false);
			tpErrorGobbler.setDaemon(true);
			tpErrorGobbler.start();
			
			writer = new BufferedWriter(new OutputStreamWriter(process.getOutputStream()));
		} catch (Exception e) {
			e.printStackTrace();
			firePGIPEvent(new PGIPError(this, "Could not start session: "+e.getMessage() ));
		}		
	}
	
	/**
	 * Create a socket to a remote (already running) prover process.
	 * Hooks the new socket up to the reader and writer.
	 * @param hostName
	 * @param port
	 * @throws IOException
	 */
	protected void startSocketSession(String hostName,int port) throws IOException {
		firePGIPEvent(new PGIPEvent(this,"Attempting to connect to remote system: " +
				hostName+":"+port, null));
		socket = new Socket(hostName,port);
		writer = new BufferedWriter(new OutputStreamWriter(
				socket.getOutputStream() ));
		BufferedReader reader = new BufferedReader(new InputStreamReader(
				socket.getInputStream() 
		));
		tpOutputGobbler = new StreamGobbler("Socket-Output", reader, this, true);
		tpOutputGobbler.setDaemon(true);
		tpOutputGobbler.start();
		//error gobbler probably not needed here, as comes from socket, no separate error stream --AH
	}
	
	public int SHUTDOWN_TIMEOUT = 5000;
	/**
	 * Shut down the theorem prover if running (okay to call multiple)
	 * @param cause the action causing this; can be null
	 */	
	public void stopSession (Object cause) {
		Process oldProc = null;
		if (process!=null) {
			synchronized (this) {  //synchronize with stream gobbler noteProcessStopped
				proverState.setAlive(false);  //set the alive status to false
				oldProc = process;
				process = null; //to prevent stream closure from giving errors
			}
		}
		if (oldProc!=null) try {
			firePGIPEvent(new PGIPShutdown(this, "manual prover stop", null));  //TODO could have stream notify on quit
			killQueue("prover stopped");
			
			//TODO first check not busy, if it is we should interrupt it
			DocElement stop = new DocElement(proverInfo.syntax.STOP_COMMAND,null);
			synchronized (firingSequence) {
				privateListener = null;  //clear this
  			sendCommand(new CommandQueued(this, stop, cause));
			}
			
			//doesn't get a response, so wait for theorem prover -AH
			long time = System.currentTimeMillis();
			int exitCode = -256;  //marker that we have not exitted yet			
			while (System.currentTimeMillis()-time<SHUTDOWN_TIMEOUT && exitCode==-256) {
				//wait up to one second for isabelle to exit
				try {
					exitCode = oldProc.exitValue();
				} catch (Exception e) {
					Thread.sleep(100);
				}
			}
			//System.out.println("prover exitted after "+(System.currentTimeMillis()-time)+"ms with exit code "+exitCode);
			if (exitCode!=0) {
				if (exitCode==-256) System.err.println("isabelle did not exit after "+General.makeTimeString(SHUTDOWN_TIMEOUT)+
				"; destroying process.");
				//else System.err.println("isabelle ended with exit code "+exitCode);
			}
		} catch (Exception e) {e.printStackTrace();}
		try {writer.close();} catch (Exception e) {/*e.printStackTrace();*/}
		try {tpOutputGobbler.interrupt();} catch (Exception e) {/*e.printStackTrace();*/}  //changed stop to interrupt, since stop is deprecated		
		try {if (tpErrorGobbler!=null) tpErrorGobbler.interrupt(); } catch (Exception e) {/*e.printStackTrace();*/} finally { tpErrorGobbler = null; }  //--AH
		try {if (process != null) process.destroy();} catch (Exception e) {/*e.printStackTrace();*/}
		try {if (oldProc != null) oldProc.destroy();} catch (Exception e) {/*e.printStackTrace();*/}
		try {if (socket != null) socket.close();} catch (Exception e) {/*e.printStackTrace();*/}
		try {unlockAll();} catch (Exception e) {/*e.printStackTrace();*/}
		proverState.setAlive(false);
		ThreadPool.get().closeAll();		
		//these clears are probably not necessary, but i put them here just to be sure  -AH
		setActiveScript(null, null);
		this.lockedScripts.clear();	
		this.incompleteOutput = new StringBuffer("");
	}
	/** stops the session, but in the background; used on shutdown */
	public void stopSessionBg (final Object cause) {
		try {unlockAll();} catch (Exception e) {/*e.printStackTrace();*/}   //do this here to prevent display.async errors later
		new PooledRunnable() {
			public void run() {
				stopSession(cause);
			}
		}.start();
	}
	
	/**
	 * Add a document to the list of those controlled by the Session Manager
	 * Called by ProofScriptDocumentProvider
	 * @param doc
	 */
	public void controlDocument(IProofScriptDocument doc) {
		if (!controlledDocuments.contains(doc))
			controlledDocuments.add(doc);
	}
	/**
	 * Remove a document from the list of those controlled by the Session Manager
	 * 
	 * @param doc
	 */
	/*public void freeDocument(ProofScriptDocument doc) {
	 if (controlledDocuments.contains(doc))
	 controlledDocuments.remove(doc);
	 if (lockedScripts.contains(doc)) lockedScripts.remove(doc);
	 if (activeScript==doc) activeScript=null;
	 doc.unlock();
	 }*/
	/**
	 * Documents controlled by this session manager 
	 * - unlocked (but not freed) if its session is terminated
	 */
	public List controlledDocuments = new ArrayList();
	/**
	 * A list of IResources that have been entirely processed.
	 */
	public List lockedScripts = new ArrayList();
	
	public void unlockAll() {
		//final ProofScriptDocument fdoc;
		for(Iterator i = controlledDocuments.listIterator(); i.hasNext();) {
			final IProofScriptDocument fdoc = (IProofScriptDocument) i.next();
			if (activeScript==fdoc) activeScript=null;
			if (fdoc!=null) {
				//ProofGeneralPlugin.isEclipseMode())   //can't have docs unless we're in eclipse mode
				//System.err.println("UNLOCKING "+fdoc);
				//...it (used to?) sometimes hang here, if it's called after eclipse shutdown (eg by stopSessionBg)
				org.eclipse.swt.widgets.Display.getDefault().asyncExec(
						new Runnable() {
							public void run() {
								fdoc.unlock();
							}
						}
				);
				//System.err.println("DONE UNLOCKING "+fdoc);
			//for some odd reason, on shutdown the code below threw java.lang.NoClassDefFoundError: ed/inf/proofgeneral/sessionmanager/SessionManager$2 
//					new Runnable() {
//						public void run() {
//							fdoc.unlock();
//						}
//					});			
			}
			i.remove();			
		}
		lockedScripts = new ArrayList();
	}
	
	/**
	 * Add/check wrapping on a command -- needs to be fast, called in sync block
	 * @param command
	 * @return
	 */
	public String packageCommand(String command, int seq) {
		if (command == "") return command; // reject empty commands
		command = pgipPackaging(command, seq);
		// ensure all commands end with a suitable line break
		String lineEnd = lineEnd();		
		if (!command.endsWith(lineEnd)) command += lineEnd;
		return command;
	}
	
	/**
	 * @return the line end character for this theorem prover
	 */
	String lineEnd() {
		String lineEnd = proverInfo.getString(Constants.SETTING_LINEEND);
		if (lineEnd.equals("")) lineEnd = "\n"; // default to unix
		if (lineEnd.equals("\\n")) lineEnd = "\n";
		else if (lineEnd.equals("\\r\\n")) lineEnd = "\r\n";
		else if (lineEnd.equals("\\r")) lineEnd = "\r";
		return lineEnd;
	}
	
	
	/**
	 * Add PGIP wrapping to a non-pgip command
	 * @param command
	 * @return
	 */
	public String pgipPackaging(String command, int seqNo) {	    
		if (proverInfo.getBoolean("add PGIP packaging")) {
			if (command.indexOf("<pgip ") == -1 && command.indexOf("<PGIP ") == -1) {				
				command = "<pgip class=\""+pgipClass+"\" id=\""+pgipId+"\" seq=\""+seqNo +"\">"
				+command+"</pgip>";
			}
		}		
		return command;
	}

	//this sends the next command when PGIPCmdProc is processed
	QueueUpdater qUpdater = null;
	/** extra listener to send the next item from the queue */
	public class QueueUpdater implements PGIPListener {
		public void pgipEvent(PGIPEvent event) {
			if (event instanceof CommandProcessed) {
				sendAnyQueuedEvent();  
			}		
		}
		public void dispose() {
			// as a listener
			for(Iterator i = talkers.iterator(); i.hasNext();) {
				try {((PGEventMaker)i.next()).removeListener(this);}
				catch (Exception x) {}	        
			}
		}
		public void addTalker(PGEventMaker listenee) {
			talkers.add(listenee);
		}
		public void removeTalker(PGEventMaker listenee) {
			talkers.remove(listenee);
		}
	}
	
	/**
	 * Is it daft to listen to our own events? 
	 This method does things like generating ancillary events
	 
	 Implements an aspect of the undo behaviour:
	 ASSUMPTION: commands that cause errors (other than nonfatal errors) do not have any effects.
	 They therefore do not need to be undone.
	 */
	public void pgipEvent(PGIPEvent e) {
		if (e instanceof CommandProcessed) {
			//used to update command in document, but now do that in proverState.modelEvent						
				//try {					
			//sendAnyQueuedEvent();   //also used to sendAnyQueuedEvent by now do that in QueueUpdater
				//} catch (ScriptingException se) {   //no longer throws this -AH
//					// this prob. indicates that the connection is dead
//					System.err.println("SessionManager.pgipEvent couldn't send next command");
//					se.printStackTrace();
//					killQueue(se.getMessage());
				//}
		} else if (e instanceof PGIPError) {
       //now this is done by processOutput, because otherwise the CommandCausedErrorEvent might not fire until after CommandProcessed
//			if (((PGIPError)e).nonFatal())
//				return; // we can ignore this error
//			//ditch the rest of the command queue
//			//i think the code here was buggy, old code in comments below  -AH	        
//			DocElement cmd = null;				
//			// send command caused error event
//			CommandQueued cq = (CommandQueued)activeCommandLookup.get(new Integer(e.refseq));
//			PGAction cause = null;
//      cmd = (commandHistory.isEmpty() ? null : (DocElement) commandHistory.pop()); 			 //had skipped this
//			if (cq!=null) {
//				cmd = cq.command;  //should be the same... check ??
//				cause = cq.cause;
//			}
//			//PGAction cause = (PGAction) commandCausers.get(bogus);
//			//if we're listening to this, it didn't have a private listener, so send to everyone
//			firePGIPEvent(new CommandCausedErrorEvent(this,cmd,e.getText(),cause));			cmd = (commandHistory.isEmpty() ? null : (DocElement) commandHistory.pop());
//			killQueueBut("An earlier command caused an error.", cq);  //don't remove this command from the queue; the Ready message should do that -AH        
//			//but don't kill first item on queue
			
			//	        if (commandQueue.size()>0) {
			//            DocElement bogus = (DocElement) commandQueue.remove(0);
			//              // send command caused error event
			//            PGAction cause = (PGAction) commandCausers.get(bogus);
			//            commandHistory.remove(bogus); // this command is no longer part of the history, since it was never executed.
			//              firePGIPEvent(new CommandCausedErrorEvent(this,bogus,e.getText(),cause));
			//            killQueue("An earlier command caused an error.");
			//        }
		} else if (e instanceof PGIPIncoming) {
			// handle PGIP-related handshake traffic that needn't go outside the session manager
			// HACK: This is only needed when dealing with the broker.
			if (e.parseTree.selectSingleNode("//"+PGIPSyntax.HANDSHAKE_ASKPGIP) != null) {
				DocElement response = new DocElement(PGIPSyntax.HANDSHAKE_USESPGIP,null);
				try {
					//	                response.addAttribute("version",pgipVersion);
					response.addAttribute("version","2.0"); // HACK: This is a lie!
					//	                processOutput("<pgip><ready/></pgip>"); // HACK: fake a ready message since the broker doesn't send them
					queueCommand(response);
				} catch (Exception x) {x.printStackTrace();}
			}
			if (e.parseTree.selectSingleNode("//"+"knownprover") != null) {
				// HACK: this is all rather ugly
				Element kp = (Element) e.parseTree.selectSingleNode("//"+"knownprover");
				//                processOutput("<pgip><ready/></pgip>"); // HACK: fake a ready message since the broker doesn't send them
				DocElement response = new DocElement("launchprover",null);
				try {
					response.addAttribute("componentid",kp.attributeValue("componentid"));
					queueCommand(response);
				} catch (Exception x) {x.printStackTrace();}
			}
		}
		
		try {
			proverState.modelEvent(e);
		} catch (ScriptingException ex) {
			if (ProofGeneralPlugin.getDefault()!=null) 
				ErrorUI.getDefault().signalError(ex);
			ex.printStackTrace();
		}
	}
	
	/**
	 * Kill the command queue (removing all queued commands), also clearing any prover ownership.
	 * Generates a stream of @see CommandCausedErrorEvent with the message.
	 * <p/>
	 * note that if a command is in the middle of being processed it will give minor errors.
	 * use killQueueBut to kill everything but a particular command.
	 */
	public void killQueue(String msg) {
		killQueueBut(msg, null);
		releaseOwnership(null);
	}
	/**
	 * Kill the command queue (removing all queued commands), except for the indicated command
	 * Generates a stream of @see CommandCausedErrorEvent with the message.
	 */
  public void killQueueBut(String msg, CommandQueued cq) {
		//System.out.println("killing queue (size "+commandQueue.size()+"), "+msg);
		synchronized (commandQueue) {
			for (int i=0; i<commandQueue.size(); ) {
				CommandQueued cmd = (CommandQueued) commandQueue.get(i);
				if (cmd==cq) i++;
				else {
					commandQueue.remove(i);
					activeCommandLookup.remove(new Integer(cmd.seq));
					try {
						cmd.preFire();
						firePGIPEvent(new CommandCausedErrorEvent.CommandCancelled(this, cmd.command, msg, cmd.cause));
						firePGIPEvent(new CommandProcessed(this, cmd.command, cmd.cause));
					} finally {
						cmd.postFire();
					}
				}
			}
		}
	}
	
	/**
	 * Add a command to the queue to be sent.
	 * triggers sendCommand if the queue is empty. 
	 * Checks whether this editor is active.
	 * @param command
	 * @param editor the editor to check against this command (if not null)
	 * @param cause  the action (if known) that caused this command to be queued.
	 * @return true, if the command has been processed, false if we are waiting on the prover
	 * @throws IOException
	 */
	public boolean queueCommand(DocElement command, IProofScriptEditor editor, Object cause) 
	throws ScriptingException {
		if (command.fDocument != null) activeCheck(command.fDocument, editor);
		return queueCommand(new CommandQueued(this, command, cause));
	}
	
	/**
	 * Add a command to the queue to be sent.
	 * triggers sendCommand if the queue is empty. 
	 * Checks whether this editor is active.
	 * Allows setting SessionManager values for the command
	 * @param command
	 * @param editor the editor to check against this command (if not null)
	 * @param cause - the action (if known) that caused this command to be queued.
	 * @param backgroundThread  (set null to use previous)
	 * @param logging  (set null to use previous)
	 * @param privateListener the PGIPListener wrapped; if null use previous,
	 * if wrapped null, explicitly set no private listeners for this command
	 * @return true, if the command has been processed, false if we are waiting on the prover
	 * @throws IOException
	 */
	public boolean queueCommand(DocElement command, IProofScriptEditor editor, Object cause,
      Boolean backgroundThread, Boolean logging, MutableObject privateListener) 
	throws ScriptingException {
		if (command.fDocument != null) activeCheck(command.fDocument, editor);
		return queueCommand(new CommandQueuedWithValues(this, command, cause, backgroundThread, logging, privateListener));
	}
	
	public boolean queueCommand(CommandQueued cq) {
		synchronized (commandQueue) {
			commandQueue.add(cq);
			if (commandQueue.size()==1)
				return sendAnyQueuedEvent();
			return false;
		}
	}
			
	
	//new method to queue things that aren't part of a document --AH
	/** queues a command, should not have any xml chars */
	public void queueCommand(String command) throws ScriptingException {
		queueCommand(new DummyDocElement(command));
	}
	
	//new method to queue things that aren't part of a document --AH
	/** queues a command element (not a doc element) */
	public void queueCommand(Element ce) throws ScriptingException {
		queueCommand(new DummyDocElement(ce));
		//    Element pr = (Element) ce.elements().get(0);	      
		//    DocElement cmd = new DocElement(ce.getName(),null);
		//    cmd.add(pr.createCopy());
		//    //command.addText(s);
		////		DocElement de = new DocElement("command", null);
		////		de.add(e);
		//		queueCommand(cmd);
	}
	
	/**
	 * Wrap a string as a proof command and add it to the queue
	 * @param command
	 * @throws ScriptingException
	 */
	/*public void queueCommand(String command) throws ScriptingException {
	 DocElement com = new DocElement(PGIPSyntax.COMMAND,null);
	 queueCommand(com,null);
	 }*/
	/**
	 * Send a command that doesn't have an associated script editor
	 * @param command
	 * @throws ScriptingException
	 * @return true, if the command has been processed, false if we are waiting on the prover
	 */
	public boolean queueCommand(DocElement cmd) throws ScriptingException {	    
		return queueCommand(cmd,null,null);
	}
	
	/**
	 * The document that is currently being scripted
	 */
	protected ProofScriptDocument activeScript = null;
	/**
	 * @return Returns the activeScript.
	 */
	public ProofScriptDocument getActiveScript() {
		return activeScript;
	}
	
	public boolean canChangeScript() {
		if (getActiveScript()==null) return true;
		if (getActiveScript().fLockOffset<=0) return true;		
		//if ended, active script is null so no need to check it
		return false;
	}
	
	/**
	 * @param activeScript The activeScript to set.
	 */
	public void setActiveScript(ProofScriptDocument activeScript, IProofScriptEditor ed) {
		if (activeScript == this.activeScript) return;
		this.activeScript = activeScript;
		scriptingEditor = ed;
		firePGIPEvent(new ActiveScriptChangedEvent(this));
	}	 
	public IProofScriptEditor scriptingEditor = null;
	
	/**
	 * Check that this document is (or can be made) active for scripting
	 * @param doc
	 * @param editor
	 * @throws ScriptingException
	 */
	public void activeCheck(ProofScriptDocument doc,IProofScriptEditor editor) 
	throws ScriptingException {
		controlDocument(doc);
		if (activeScript == null) {
			setActiveScript(doc,editor);
			return;
		}
		if  (doc==activeScript) return;
		//check if the script really is active
		if (activeScript.fLockOffset<=0) {
			//it's not been read yet (or been retracted)
			setActiveScript(null, null);
			
			return;
		}
		//user has not issued "end" command yet... do not close document
		//(plus this check can be expensive)
//		try {
//			if (false && getParser().findNextCommand(activeScript)==null) {   //TODO remove this false				
//				//it's been completely parsed
//				//this is a bit buggered; plus it can be called from main thread!
//				activeScript.lock(this);							
//				setActiveScript(null, null);
//				return;
//			}
//		} catch (ScriptingException e) {
//			ErrorUI.getDefault().signalError(e);
//		}
		
		ScriptingException e = new ScriptingException("Attempt to script "+doc.title+" when "+
				activeScript.title+" is active.\n\n"+
		"Close the active script first!");
		//TODO should show filenames here
		//TODO ideally we would give the force/cancel/etc message here
		//TODO or better, this has boolean semantics and callers give that option
		//	    ErrorUI.getDefault().signalError(e); this should be done higher up	    
		throw e;
	}
	
	/**
	 * Given a command element, decide what string to send out
	 * sub-classes can over-ride to implement non-standard behaviour
	 * The default is just to splat it into xml, replace symbols with ascii
	 * according to how the parser has structured it
	 * @param command
	 * @return
	 */		
	//made public and applicable to any element --AH
	public String getCommandString(Element command) {
		String cs;
		//String cName = command.getName();  //not used so don't bother 
		if (!proverInfo.getBoolean(Constants.PREF_USE_PGIP)) {
			cs = command.getText();	        
		} else cs = command.asXML();
		cs = HTMLSymbols.useEscapedAscii(cs);
		return cs;		
	}	
	
	
	/**
	 * Send a command out to the prover - but ignores the queue. 
	 * Most uses should use queueCommand. 
	 * 
	 * Will convert into a PGIP message & add a linebreak to the end if necc.
	 * 
	 * rejects ""
	 * @param command
	 * @return true, if the command has been processed, false if we are waiting on the prover
	 */
	public boolean sendCommand(CommandQueued co)   //TODO shouldn't be public 
	//throws ScriptingException 
	{
		DocElement command = co.command;
		if (internalUseOnly(command)) {
			fakeSendCommand(command);
			return true;
		}
		String commandString;
		if (command==null) {
			return false;
		}
		commandString = getCommandString(command);
		try {
			synchronized (firingSequence) {  //make sure outgoing is fired before incoming -AH
				co.setSeqNo(currentSeqnNo++);
				commandString = packageCommand(commandString, co.seq);
				proverState.setBusy(true);
				setTimeout(ProofGeneralPlugin.getIntegerPref(Constants.PREF_TIME_OUT),false);
				co.sent = true;
				co.onSend();
				if (ProofGeneralPlugin.LOG_PROVER_IO) System.out.println(General.makeDateString()+"  SEND: "+commandString);
				lastProverAction = System.currentTimeMillis();
				writer.write(commandString);
				writer.flush();	
				try {
					co.preFire();				
					if (logging) { //not needed as undo now sets logging false && !proverInfo.syntax.subType(command.getType(), PGIPSyntax.UNDO))
						//System.err.println("commandHistory.push "+command.asXML());
						commandHistory.push(command);
					}
				  firePGIPEvent(new PGIPOutgoing(this,command,co.cause));
				} finally {
					co.postFire();
				}
			}
		} catch (Exception e) {
			proverState.setBusy(false);
			PGIPError err = new PGIPError(this, "Cannot send command "+command.asXML()+": "+e.getMessage(), command);
			err.seq = co.seq;
			try {
				co.preFire();				
				firePGIPEvent(err);
			} finally {
				co.postFire();
			}
		}
		return false;
	}
	/** sends a command from the queue, if not empty; returns whether a command was sent (whether queue was non-empty) */
	boolean sendAnyQueuedEvent() { //throws ScriptingException {
		synchronized (commandQueue) {
			if (!commandQueue.isEmpty()) {
				CommandQueued cmd = 
					(CommandQueued) commandQueue.get(0);				  //@TODO currently this is removed when it has been processed, maybe change
				  //(CommandQueued) commandQueue.remove(0);
				if (!cmd.sent) sendCommand(cmd);
				return true;
			} else
				commandQueue.notifyAll();  //notify anyone listening on the queue that it has emptied
		}		
		return false;
	}
		
	/**
	 * Send a command to Proof General
	 * (in principle, it should be as if it came from the theorem prover,
	 * but for now we will have a special channel)
	 * @param cmd
	 */
	void fakeSendCommand(DocElement cmd) {
		firePGIPEvent(new PGIPOutgoing(this, cmd, null));
		firePGIPEvent(new PGCommandReceived(this, cmd));
	}
	
	/**
	 * Used to send out random snippets
	 * bypasses the command queue 
	 * (and does not log commands in the history, though responses will be logged in messageHistory)
	 * @param command
	 */
	//	public void sendDirectCommand(String command) {
	//	    String commandString = packageCommand(command);
	//		try {
	//		    proverState.setBusy(true);
	//			writer.write(commandString);
	//			writer.flush();	
	//			//proverResponded = false;
	//			//commandHistory.push(command);
	//			firePGIPEvent(new PGIPOutgoing(this,commandString));
	//		} catch (Exception e) {
	//		    proverState.setBusy(false);
	//			firePGIPEvent(new PGIPError(this,"Cannot send command: "+e.getMessage(),command));
	//		}
	//	}

	/** kills active commands, kills the queue, releases ownership, and sends an interrupt signal if busy */
	public void doInterrupt() throws ScriptingException {
		if (activeFiredEvents.size()>0) {
			//this only interrupts events that are running (ie have gotten their firingQueueSequence)
			//TODO maybe instead we should traverse the "fired" events queue in reverse order,
			//in such a way that they don't update the firingQueueSequence number
			FirePGIPEventThread activeFiredEvent = (FirePGIPEventThread)(activeFiredEvents.get(0));
			if (ProofGeneralPlugin.LOG_INTERRUPT_ACTIONS) System.out.println("interrupting "+activeFiredEvent);
			if (activeFiredEvent.interruptTask())
			  return;
			else {
				synchronized (firingSequence) {
					if (activeFiredEvents.remove(activeFiredEvent)) {
						if (ProofGeneralPlugin.LOG_INTERRUPT_ACTIONS) System.out.println("interrupt: "+activeFiredEvent+" wasn't actually active, reset it");
						return;
					} else {
						if (ProofGeneralPlugin.LOG_INTERRUPT_ACTIONS) System.out.println("interrupt: "+activeFiredEvent+" vanished; continuing with interrupt");
					}
				}
			}
		}
		synchronized (commandQueue) {
			//synchronise this to prevent others from modifying/processing the queue			
			releaseOwnership(null);  //TODO should we force an ownership release ?? -- maybe only if pressed twice ? -- what about interrupting all threads?, or query 'Interruptible' interface on owner 
			if (proverState.isBusy()) {
				if (ProofGeneralPlugin.LOG_INTERRUPT_ACTIONS) System.out.println("interrupt is killing prover queue (had "+commandQueue.size()+" elements) then interrupting prover (because it is busy)");
				//if the prover is busy, send the interrupt signal				
				interruptedFlag = true;  //only necessary if busy
				killQueue("Interrupt");
				sendInterrupt();
			} else if (commandQueue.size()>0) {
				if (ProofGeneralPlugin.LOG_INTERRUPT_ACTIONS) System.out.println("interrupt is killing prover queue (had "+commandQueue.size()+" elements)");
				killQueue("Interrupt");
			}
		}
	}
	
	/**
	 * Interrupt the prover. Uses the preference settings to determine how to do this.
	 * Does *not* adjust the queue.
	 *
	 */
	public void sendInterrupt() throws ScriptingException {
		//throw new RuntimeException("Not Implemented Yet.\n (sorry)");
		//i think what we need is  "kill -2 PID"   -AH
		if (!proverState.isBusy()) return;   //only send if busy, otherwise we terminate
		try {
			System.err.println("INTERRUPT is using 'killall -2 poly'");
			Runtime.getRuntime().exec("killall -2 poly");
		} catch (Exception e) {
			e.printStackTrace();
		}
		
		//		try {
		//		    if (proverInfo.getBoolean(Constants.SETTING_KEY_PGIP_INTERRUPT)) {
		//		        DocElement bashta = new DocElement(PGIPSyntax.INTERRUPT,null);
		//		        sendCommand(bashta);
		//		    } else { // send a control-c interrupt
		//		        char i = 3; // FIXME test, make interrupt work 
		//		        //proverState.setBusy(false);		    
		//		        writer.write(i); writer.write(lineEnd());
		//		        writer.flush();
		//		    }
		//			//proverResponded = false;
		//			//commandHistory.push(command);			
		//			//firePGIPEvent(new PGIPOutgoing(this,commandString));
		//		} catch (Exception e) {
		//		    proverState.setBusy(false);
		//			//firePGIPEvent(new PGIPError(this,"Cannot send command: "+e.getMessage(),command));
		//		}		
	}
	
	/**
	 * If sessionManager has not heard from the prover within msecs, 
	 * throw a pgip error
	 * Note: We only support timing the last command sent
	 * if there is an existing time out, then calling setTimeout cancels it
	 * @param msecs - do nothing if < 1
	 * @param fatal - If true, a timeout error will trigger a prover process shutdown.
	 */
	
	public void setTimeout(int msecs,boolean fatal) {	    
		if (msecs<1) return;
		if (timeOuter != null) timeOuter.cancel(); // stop old time out, if set
		timeOuter = new Timer(true);
		TimerTask checkDone = new CheckDone(this,fatal);		
		timeOuter.schedule(checkDone,msecs);
	}
	Timer timeOuter = new Timer(true);
	//boolean proverResponded = true;
	public static final String TIMEOUT_ERROR_TEXT = "Command Timed Out";
	
	
	/**
	 * contains a PGIP undo model hack:
	 * If the last command was the end of a proof, 
	 * we will have to undo the whole proof + the theorem/lemma
	 * This code assumes that the lemma command comes directly before the proof in the commandHistory
	 * 
	 * @return true, if the command undoes instantly (ie. it didn't really need to be undone; note it will still generate events),
	 * false, if the undo has been sent off and it will be some time before the undo is complete.
	 */
	public boolean undoLastScriptCommand(ProofScriptDocument script, Object cause) 
	throws Exception {
		activeCheck(script,null);
				
		//first check the command queue, removing the last element which is from this script
		if (!commandQueue.isEmpty()) {
			//TODO this will probably bugger the event model, see 'cause' below (interrupt them instead?)
			synchronized (commandQueue) {
				if (!commandQueue.isEmpty()) {
					for (int i=commandQueue.size()-1; i>-1; i--) {        
						CommandQueued qcq = (CommandQueued) commandQueue.get(i);						
						System.err.println("undoing item from the queue (may fail): "+qcq.command.asXML());
						if (qcq.command.fDocument == script) {
							commandQueue.remove(i);
							try {								
								qcq.preFire();
							  qUndo(qcq.command, cause);  //need to inform Send/Undo's in the queue by passing them their cause
							} finally {
								qcq.postFire();
							}
							return true;
						}
					}						
				}
			}
		}
		
		DocElement oldCommand = null;
		//should we kill the queue ?  don't think so on undo.
		//killQueue("Cancelled by the user.");
		for (int i=commandHistory.size()-1; i>-1; i--) {        
			oldCommand = (DocElement) commandHistory.get(i);
			if (oldCommand.fDocument == script) break;	        	
			oldCommand = null;
		}	    
		if (oldCommand == null) 
			throw new ScriptingException("Cannot undo: There are no script commands to undo.");
		
		if ((!ProofGeneralPlugin.SEND_OLD_STYLE_UNDO_INSTEAD_OF_UNDOITEM &&
				 (!proverInfo.syntax.subType(oldCommand.getType(),proverInfo.syntax.COMMAND) ||
				    proverInfo.syntax.subType(oldCommand.getType(),proverInfo.syntax.SPURIOUSCOMMAND))) ||
				(ProofGeneralPlugin.SEND_OLD_STYLE_UNDO_INSTEAD_OF_UNDOITEM &&
				 ((!proverInfo.syntax.subType(oldCommand.getType(),proverInfo.syntax.COMMAND) && 
				 	 !proverInfo.syntax.subType(oldCommand.getType(),proverInfo.syntax.FORMALCOMMENT)) ||
					proverInfo.syntax.subType(oldCommand.getType(),proverInfo.syntax.SPURIOUSCOMMAND)))) {
			//in general, dummy undo spurious commands and anything not a command
			//if using old ProofGeneral.undo, don't dummy undo litcommands
			//System.err.println("commandHistory.remove "+oldCommand.getStringValue());
			commandHistory.remove(oldCommand);
			qUndo(oldCommand, cause);
			return true;
		}
		// cannot undo into a proof !HACK this implements the undo model
		if (proverInfo.syntax.subType(oldCommand.getType(), PGIPSyntax.CLOSETHEOREM)) {
			//now on close theorem, we go back through the history looking for an open theorem command,
			//instead of relying on the document parse (below) -AH
			//TODO this might break nested things like isar scripts! 
			try {
				DocElement thm = (DocElement) commandHistory.pop();
				while (thm!=null && !proverInfo.syntax.subType(thm.getType(), PGIPSyntax.OPENTHEOREM)) {
					thm = (DocElement)commandHistory.pop();
				}
				if (thm==null) throw new EmptyStackException();
				//this tells the prover to undo the OPEN theorem element, as opposed to the close theorem element; it works... 
				undo(thm,cause);				
			} catch (EmptyStackException e) {
				throw new ScriptingException("Undo called on the end of a theorem, but there was no open theorem command in the history! The prover probably has to be restarted.");
			}
		} else if (outerProof(oldCommand) != null && proverState.getState()!=proverState.PROOF_LEVEL) {
			System.err.println("Undoing inside of a theorem's proof element but not undoing a close theorem element");
			//shouldn't come here any more
			//this uses the document parse (old code), and works, but not for standalone
			DocElement proof = outerProof(oldCommand);			
			int start = proof.getPosition().offset;
			DocElement thm = null;
			while( ((DocElement) commandHistory.peek()).getPosition() == null ||
					((DocElement) commandHistory.peek()).getPosition().offset >= start ) 					
			{ // TODO what if a proof straddles the queue/history stacks? this probably screws up
				//System.err.println("commandHistory.pop");
				thm = (DocElement)commandHistory.pop();
			}
			//now no longer needed -- the outerproof *is* the opentheorem element
			//System.err.println("commandHistory.pop");
//			DocElement thm = (DocElement) commandHistory.pop();
//			// check that this is a theorem
//			if (!proverInfo.syntax.subType(thm.getType(),proverInfo.syntax.OPENTHEOREM))
//				throw new ScriptingException("Undoing proof - expected to find a preceding theorem, but found "
//						+thm.getType()+" "+thm.getText());
			//this tells the prover to undo the OPEN theorem element, as opposed to the close theorem element 
			undo(thm,cause);
		} else if (proverInfo.syntax.subType(oldCommand.getType(), PGIPSyntax.CLOSETHEORY)) {
			//retracting a theory
			DocElement openTheory = null;
			do {
				if (commandHistory.size()==0) break;
				openTheory = (DocElement) commandHistory.pop();
			} while (!proverInfo.syntax.subType(openTheory.getType(), PGIPSyntax.OPENTHEORY));
			if (!proverInfo.syntax.subType(openTheory.getType(), PGIPSyntax.OPENTHEORY)) {
				System.err.println("undoLastCommand: didn't find an open theory command retract");
			}
			undo(oldCommand, cause);
		} else { // normal case
			//System.err.println("commandHistory.remove "+oldCommand.getStringValue());
			commandHistory.remove(oldCommand);
			undo(oldCommand, cause);
		}
		return false;
	}
	
	/**
	 * Find the largest proof containing this DocElement, or null
	 * @param e
	 * @return
	 */
	DocElement outerProof(DocElement e) {
		if (e==null) return null;		
		DocElement parent = (DocElement) e.getParent();
		if (proverInfo.syntax.subType(e.getType(), proverInfo.syntax.PROOF) ||
				proverInfo.syntax.subType(e.getType(), proverInfo.syntax.PROOF_CONTAINER)) {
			DocElement larger = outerProof(parent);
			if (larger!=null) return larger;
			return e;
		} else {
			//set this if we find nothing recursing upwards
			return outerProof(parent);
		}
	} 
	
	/**
	 * Check whether this command is inside a special pgtag
	 * @param e
	 * @return
	 */
	boolean internalUseOnly(DocElement e) {
		if (e==null) return false;
		if (proverInfo.syntax.subType(e.getType(), proverInfo.syntax.PGTAG)) 
			return true;
		DocElement parent = (DocElement) e.getParent();
		return internalUseOnly(parent);		
	} 
	
	/**
	 * Undo the given command,
	 * Called by undoLastScriptCommand,
	 * Does NOT remove the command from the history.
	 * Skips over misc. commands.
	 * Updates the prover state model.
	 * 
	 * ASSUMPTION: This implements the pointlessly ugly mess whereby undo
	 * has 4 different forms depending on context
	 * (surely the whole point of pgip should be to abstract this kind of detail away?).
	 * Anyway, we are assuming that the prover obeys the PG/Kit undo model:
	 *  - does not undo into a proof
	 *  - 1 and only 1 opentheory command per file
	 * 
	 * @param command
	 */
	public void undo(DocElement command, Object cause) throws ScriptingException {
		/* !HACK! This is shielding the user from a pointlessly ugly corner of pgip.
		 * The undo command for individual proof steps, and non-top-level opengoals is undostep.
		 * The undo command for complete theorems+proofs, and theory steps is undoitem 
		 * But for top-level goals, it is abortgoal. And for theories it is aborttheory. 
		 * And for files, it is retracttheory.
		 * As far as I can tell, there is no point to this at all.
		 */
		DocElement undoCmd = null;
		if (proverState.state==ProverState.PROOF_LEVEL
				&& proverState.proofDepth==1
				&& proverState.syntax.subType(command.getType(),PGIPSyntax.OPENTHEOREM))
			undoCmd = new DocElement(PGIPSyntax.UNDOTOPGOAL,null);        
		else if (proverState.state==ProverState.THEORY_LEVEL) {
			if (proverState.syntax.subType(command.getType(),PGIPSyntax.OPENTHEORY))
				undoCmd = new DocElement(PGIPSyntax.UNDOTHEORY,null);
			else {
				//the UNDOTHEORYITEM wasn't working for me... so fall back to basic .undo behaviour -AH
				//note, we need this for spurious commands also
				if (ProofGeneralPlugin.SEND_OLD_STYLE_UNDO_INSTEAD_OF_UNDOITEM) {
					undoCmd = new DocElement(PGIPSyntax.SPURIOUSCOMMAND, null); 
					undoCmd.setText("ProofGeneral.undo;");            	  
				} else {
					//was this the old way?
					undoCmd = new DocElement(PGIPSyntax.UNDOTHEORYITEM,null);
				}
			}
			
		} else if (proverState.state==ProverState.TOP_LEVEL
				&& proverState.syntax.subType(command.getType(),PGIPSyntax.CLOSETHEORY)) {
			// we are trying to undo an 'end' command
			// this requires retracting a named theory - we must first work out the theory name
			// !HACK this implements the undo model
			// It is done here rather than higher up 'cos it is not the same as undoing an opentheory command
			undoCmd = new DocElement(PGIPSyntax.RETRACTTHEORY,null);
			if (command.fDocument==null) throw new ScriptingException("Cannot find the document to undo. This is a strange and unexpected error.");
			DocElement openThy = (DocElement) Methods.treeWalk(command.fDocument.getRootElement(),
					new Fn() {                
				public Object apply(Tree node) {
					if (node instanceof DocElement) {
						if (proverInfo.syntax.subType( ((DocElement)node).getType(), PGIPSyntax.OPENTHEORY))
							return node;
					}
					return null;
				}                
			});
			if (openThy==null) throw new ScriptingException("Tried to retract a theory, but can't locate the opentheory command to retract.");
			String name = openThy.attributeValue("thyname");   //shoudl be thid
			undoCmd.addAttribute("thyname",name);
			queueCommand(undoCmd,null,cause);
			//TODO the prover model could get this info by monitoring outgoing UNDO events; then if prover complains, model will know
			proverState.modelEvent(new InternalEvent.UndoSent(this,command));
			// need to undo the open theory command
			if (command.fDocument != null) command.fDocument.commandUndone(openThy);
			return;
		} else if (ProofGeneralPlugin.SEND_OLD_STYLE_UNDO_INSTEAD_OF_UNDOITEM &&
				proverState.syntax.subType(command.getType(),PGIPSyntax.SPURIOUSCOMMAND)) {
			undoCmd = new DocElement(PGIPSyntax.SPURIOUSCOMMAND, null); 
			undoCmd.setText("ProofGeneral.undo;");            	  
		} else {			
			undoCmd = new DocElement(PGIPSyntax.UNDO, null);
		}
		
		if (undoCmd!=null) queueCommand(undoCmd,null,cause, null, Boolean.FALSE, null);  //don't log
		proverState.modelEvent(new InternalEvent.UndoSent(this,command));
		// if this command came from a proof script, unlock it
		if (command.fDocument != null) command.fDocument.commandUndone(command);
	}
	/**
	 * Pretend undo for commands that were queued but never executed
	 * and for spurious commands (which don't need to be undone).
	 * @param command
	 */
	public void qUndo(DocElement command, Object cause) {
		firePGIPEvent(new PGIPEvent(this,"Dummy Undo: "+command.asXML(), cause));
		firePGIPEvent(new CommandProcessed(this,"<dummyUndo/>", cause));
		firePGIPEvent(new PGIPReady(this,""));
		// if this command came from a proof script, unlock it
		if (command.fDocument != null) command.fDocument.commandUndone(command);	
	}
	
	/** the UTC time of the last prover input or output */ 
	public long lastProverAction = -1;
	
	/**
	 * Store partial output for a bit
	 */
	protected StringBuffer incompleteOutput = new StringBuffer("");
	
	/*
	//TODO not sure when is best time to go ahead and send the next element from the queue -AH
	public static final int WHEN_TO_SEND_NEXT_FROM_QUEUE = _ON_READY;
	public static final int _ON_READY_RECEIVED = 1;
	//advantage of ON_READY is that things happen faster when there's a queue
	//disadvantage is that if there is a fatal error it might not be realised in time to clear the queue (that is done by sm.pgipEvent handler)
	public static final int _ON_CMD_PROC_EVENT = 2;
	//disadvantage is that if someone else takes cmd proc event, the queue might hang !!	
	//none of this is implemented, BTW
	*/
	
	/**
	 * Process output from the theorem prover, firing off events
	 * also removes the processed command from the queue
	 * Calls parseTpOutput, which does the work of creating PGIP events
	 * Sub-class this method to change the detection of ready messages 
	 * NB: <b>USED</b> to add <br/> tags to help the html based displays down the line. 
	 * Does not anymore, 'cos the broker sends fragments with linebreaks inside a tag. 
	 * @param output
	 */
	protected void processOutput(String output) {	    
		if (ProofGeneralPlugin.debug()) {
			System.out.println("TP: "+output);
		}
		lastProverAction = System.currentTimeMillis();
		if (ProofGeneralPlugin.getBooleanPref(Constants.PREF_SYMBOL_SUPPORT)) {
			output = HTMLSymbols.useUnicode(output,true); // switch early to using symbols
		}
		incompleteOutput.append(output);
		PGIPEvent[] events = parseTpOutput(incompleteOutput.toString());
		if (events == null || events.length==0) {
			//add in the new-line char
			Methods.lineEnd(incompleteOutput);
			return;
		}
		incompleteOutput = new StringBuffer("");
		if (timeOuter != null) {
			timeOuter.cancel(); // stop setTimeOut, if set
			timeOuter = null;
		}		
		//proverResponded = true;
		for(int ei=0; ei<events.length; ei++) {
			PGIPEvent event = events[ei];
			
			if (event instanceof PGIPBogus) {
				//wasn't an xml message -- we've printed messages in parseBogusOutput but here we fire it
//				if (((PGIPBogus)event).isWarning) {
//					//was a warning message, print it to stderr
//					System.err.println("prover warning: "+event.getText());
//				} else if (!startUpBumpfFlag) {
//					//unknown message type
//					//TODO stack increase messages fall in this category
//					System.err.println("prover message: "+event.getText());
//				}
				synchronized (firingSequence) {
					//but let everyone know about it just the same (especially the log)					
					firePGIPEvent(event);				
				}				
				continue;
			}
			//new model takes from active command lookup; synchronized on it with interruptions, new commands added
			//(doesn't actually need to be synchronized with new commands added but it's all fast, so no realy problem)
			synchronized (commandQueue) {

			CommandQueued cq = null;
			if (event.refseq>=0) cq = (CommandQueued)activeCommandLookup.get(new Integer(event.refseq));
			if (!(event instanceof TimeOutError) && !proverState.isAlive()) {
				//if not alive, check that process is still okay, then try setting alive
				synchronized (this) {
					if (process!=null) proverState.setAlive(true);
				}
			}
			synchronized (firingSequence) {
				//this is wrapped in a synchronized block so the CommandProcessed events are 
				//fired before the initial events are handled -AH   (not quite sure what i meant by this... perhaps it enforces more than we need ??)
				if (cq==null) {
					//something not in active table... should be startup output -- basically do old code
					if (!startUpBumpfFlag && !interruptedFlag) {
					  System.err.println("event not in active table: "+event); 
					}
					firePGIPEvent(event);
					if ( (proverInfo.getBoolean("ready messages") && event instanceof PGIPReady)
							|| (!proverInfo.getBoolean("ready messages")) ) { // perhaps we should fake a ready message instead?
						startUpBumpfFlag = false; // if we've seen a ready message, we're no longer starting up
						interruptedFlag = false;  // if we've seen a ready message, we're no longer interrupting						
						proverState.setBusy(false);
						interruptedFlag = false;  //assume this was the response to the interruption
						if (!(event instanceof PGIPError) && commandQueue.size()>0) {
							//startup events will have nothing in queue...
							//if any other events are getting through here, they may need the processedCommand and queue size is not a good way to tell (also who would remove it)
							//TODO probably shouldn't be coming here, not sure these commands do what they should
							if (interruptedFlag) {
							  System.err.println("interrupted, but still items in queue, likely more errors will follow; when generating event: "+event); 								
							}
							CommandQueued cqo = (CommandQueued) commandQueue.remove(0);
							DocElement processedCommand = (DocElement) cqo.command;
							firePGIPEvent(new CommandProcessed(this, processedCommand, cqo.cause));													
						}
					}				
				}	else {		
					try {				
						cq.preFire();
						event.cause = cq.cause;
						firePGIPEvent(event);
						if ((event instanceof PGIPError) && (!((PGIPError)event).nonFatal())) {
							//the new way of generating "command caused error event" is to
							//look at the PGIPError we are parsing, set in in the cq object
							//then before we send the "CmdProc" we look up whether there was an error
							cq.recordError(event);
						}
						if ( (proverInfo.getBoolean("ready messages") && event instanceof PGIPReady)
								|| (!proverInfo.getBoolean("ready messages")) ) { // perhaps we should fake a ready message instead?
							startUpBumpfFlag = false; // if we've seen a ready message, then we should no longer be dealing with dodgy xml 
							proverState.setBusy(false);
							if (!(event instanceof PGIPError)) {
								//we used to do this only if there was something in the queue
								//now we don't say CommandProcessed if there was an error; maybe we should?
								//(normally a ready message will be sent as well, but if the boolean flag is set false we shouldn't wait on it)
								synchronized (commandQueue) {
									//TODO could do this removal in qUpdater ?
									if (!commandQueue.remove(cq)) {
									  System.err.println("command found for event "+event+" was not in queue");
										//could happen if we're not waiting on ready messages and we get multiple output from a command ?? no, shouldn't
								  }
									if (activeCommandLookup.remove(new Integer(cq.seq))==null) {
  								  System.err.println("command found for event "+event+" was not in active table");
  								  //how could this get removed, we just got it above, and it's all synced in commandQueue
										//could happen if we're not waiting on ready messages and we get multiple output from a command ?? no, again, shouldn't										
									}
								}
								if (cq.hadErrors()) {
									//now we deal with commands that cause errors when we get the "ready" message
									//not sure if this is best time; might be better to do right after PGIPError
									//(but then why have the separate event??)

									//will still have context for the event from above
									if (logging) {
										DocElement lastCmd = (commandHistory.isEmpty() ? null : (DocElement) commandHistory.pop());
										//if (lastCmd!=null) System.err.println("commandHistory.pop");
										if (!cq.command.equals(lastCmd)) {
											System.err.println("error in command "+cq.command.asXML()+", but top of history is "+lastCmd.asXML());
										}
									}
									firePGIPEvent(new CommandCausedErrorEvent(this, cq.command, cq.getErrorString(), cq.cause));			
									killQueueBut("An earlier command caused an error.", cq);  //don't remove this command from the queue; the Ready message should do that -AH  (moved here, it will have already done it so could just kill all now, but in case we want to move it)        
									//but don't kill first item on queue
								} else {
									firePGIPEvent(new CommandSucceeded(this, cq.command, cq.cause));
								}
								firePGIPEvent(new CommandProcessed(this, cq.command, cq.cause));								
							}
						}
					} finally {
						cq.postFire();
					}				
				}
			}
			//old model
//			if (!commandQueue.isEmpty()) {
//				// HACK! should use the refseq numbers to match responses with their causes
//				// instead of just assuming the command at the head of the queue was the cause.
//				event.cause = (PGAction) commandCausers.get(commandQueue.get(0));
//			}
//			if (!(event instanceof TimeOutError)) proverState.setAlive(true);
//			synchronized (firingSequence) {
//				//this is wrapped in a synchronized block so the CommandProcessed events are 
//				//fired before the initial events are handled -AH
//				firePGIPEvent(event);
//				if ( (proverInfo.getBoolean("ready messages") && event instanceof PGIPReady)
//						|| (!proverInfo.getBoolean("ready messages")) ) { // perhaps we should fake a ready message instead?
//					startUpBumpfFlag = false; // if we've seen a ready message, then we should no longer be dealing with dodgy xml 
//					proverState.setBusy(false);
//					if (!(event instanceof PGIPError) && commandQueue.size()>0) {
//							DocElement processedCommand = (DocElement) commandQueue.remove(0);
//  						PGAction cause = (PGAction)commandCausers.get(processedCommand);
//							firePGIPEvent(new CommandProcessed(this, processedCommand, cause));																
//					}
//				}
			}
		}
	}
	
	/**
	 * Pretend that this string came from the theorem prover.
	 * Switches to display thread just to be sure.
	 * Used as a quick hack to allow both TP and PG to use one session manager
	 */
	public void fakeOutput(String tpOutput) {
		org.eclipse.swt.widgets.Display.getDefault().asyncExec( new switchThread(this,tpOutput) );
	}
	
	//public PGIPEvent parseTpOutput(String output) {
	//return new PGIPIncoming(this,output);
	//}
	//Pattern isabelleErrorHack = Pattern.compile("<errorresponse[^>]*>(.*)</errorresponse>");
	
	/**
	 * HACK: Isabelle emits some non-XML bumpf on start up. 
	 * This flag determines whether or not to try correcting for that.
	 */
	public boolean startUpBumpfFlag = true;
	/** set true when we interrupt the process, gets reset to true on start;
	 *  used to suppress printing of error messages */
	protected boolean interruptedFlag = false;

	
	SAXReader saxReader = new SAXReader();
	/**
	 * Create an array of events for this output, or null if the output is incomplete. 
	 * Subclasses may over-ride to provide different input reading. 
	 * Assumes output will (eventually) add up to 1 complete (& only 1) pgip message.
	 * 
	 * HACK / ASSUMPTION
	 * This includes a couple of Isabelle-specific hacks that <b>break</b> PGIP:
	 * 	1) packet tags can be added to help cure reading errors. This is NOT AT ALL compatible with using the broker.
	 *  2) Leading >s (occasional old-style prompts sent by Isabelle) can be stripped off. 
	 *  
	 * @param output
	 * @return
	 */
	protected PGIPEvent[] parseTpOutput(String outputOrig) {					
		//		SAXReader reader = new SAXReader();
		Document document;
		//this parsing can take a long time; modified to be faster -AH
		boolean isXml = true;
		String output = outputOrig.trim();
		if (output.startsWith("<pgip") && !output.endsWith("</pgip>")) {
			//incomplete
			return null;
		}
		try {
			document = saxReader.read( new StringReader(output));
		} catch (DocumentException e) {
			//not valid XML			
			if (startUpBumpfFlag) {
				// HACK! to deal with occasional old-style prompts sent by Isabelle (just one, on startup)
				if (output.startsWith(">")) {
					//System.err.println("received old-style prompt from Isabelle: "+output);
					output = output.substring(1).trim();
					return parseTpOutput(output);
				}
				//non-pgip are often sent during start-up, not important, treat as bogus
				return parseBogusOutput(output);
			} else {
				//not startup, and not a pgip message; mark as bogus
				return parseBogusOutput(output);
			}
		}
		List list = document.content();
		assert list.size()==1 : "The session manager is confused - too many responses received at once.";
		Element e = (Element) list.get(0);
		e = Converter.prepare(e);  //added this because isabelle sends xml as text encoded (one level)  -AH   //TODO is this right?
		PGIPEvent[] events = makeEvents(e);
		return events;
		//} catch (Exception e) { e.printStackTrace(); return null; }
	}

	/** generates an event from certain types of recognised bogus text;
	 *  returns an event if we can make an event out of this (eg PGIPError or spurious...);
	 * for now generally this prints a message, and returns a simple error which is ignored (except on startup) */
	PGIPEvent[] parseBogusOutput(String output) {			  		  	
		//TODO should add these to the session log, in a better way
		if (output.trim().startsWith("!!!")) {
			//it's a warning, eg !!! Sorry PGIP not supported for Isabelle/classic  (if run isabelle -X without -I)
			String s = output.trim().substring(3).trim();
			System.err.println("prover warning: "+s);
			PGIPBogus ew = new PGIPBogus(this, s, null);
			ew.isWarning = true;
			return new PGIPEvent[] { ew };
		  //we could go ahead and process this as an event
			//events = new PGIPEvent[] { new PGIPError(this, s) };
		} else {
      //eg 'Warning' on increasing stack size, are not output as XML -- deal with them specially -AH
			String s = output;
			if (!startUpBumpfFlag) {
				//often outputs plain text on startup
				System.err.println("unknown non-xml prover message: "+s);
			}
			PGIPBogus ew = new PGIPBogus(this, s, null);
			return new PGIPEvent[] { ew };
		}
	}
	
	/**
	 * Create an array of events from an element of prover output.
	 * TODO: Should return multiple events if given multiple responses
	 * @param e
	 * @return
	 */
	PGIPEvent[] makeEvents(Element e) {
		PGIPEvent[] evs = new PGIPEvent[1];
		if (e.selectSingleNode("//"+PGIPSyntax.PARSERESULT) != null) {
			evs[0] = new PGIPParseResult(this,e);
		} else if (e.selectSingleNode("//"+PGIPSyntax.ERROR) != null) {
			Element err = (Element) e.selectSingleNode("//"+PGIPSyntax.ERROR);		    
			if (err.getText().startsWith(TIMEOUT_ERROR_TEXT)) {
				evs[0] = new TimeOutError(this,e);
			} else evs[0] = new PGIPError(this,e);
			((PGIPError)evs[0]).fatality= err.attributeValue("fatality");
		} else if (e.selectSingleNode("//ready") != null) {
			evs[0] = new PGIPReady(this,e);
		} else {
			evs[0] = new PGIPIncoming(this,e);
		}
		return evs;
	}
	
	
	// Message history stuff
	public int MAX_COMMAND_HISTORY = 5000;
	public LimitedStack commandHistory = new LimitedStack(MAX_COMMAND_HISTORY);
	public int MAX_MESSAGE_HISTORY = 200;
	/**
	 * A stack of all events generated by the SessionManager
	 *  - includes outgoing commands, incoming messages and internal messages
	 */	
	public LimitedStack messageHistory = new LimitedStack(MAX_MESSAGE_HISTORY);	
	//public Stack openGoals = new Stack();
	
	/**
	 * This is really a vector not a stack - we use a stack for convenience when manipulating queue+history in undo
	 */
	public List commandQueue = new ArrayList();
	
	/**
	 * A map associating commands with the actions that caused them to be sent out.
	 * To prevent overloading by large files, it will only store a limited history.
	 * Only works for commands sent through queueCommand.
	 */
	//Map commandCausers = new LimitedMap(MAX_COMMAND_HISTORY);
	
	/** a map between seq id's and commands */
	Map activeCommandLookup = new LimitedMap(MAX_COMMAND_HISTORY);  //could probably get by with '1' here...
	
	/**
	 * replace all the history objects with fresh copies
	 */
	public void clearHistory() {
		commandHistory = new LimitedStack(MAX_COMMAND_HISTORY);
		messageHistory = new LimitedStack(MAX_MESSAGE_HISTORY);
	}
	
	public void addListener(PGIPListener listener) {
		assert listener != null : "Tried to add a null listener";
		if (! fPGIPListeners.contains(listener)) {
			fPGIPListeners.add(listener);
			listener.addTalker(this);
		}
	}
	
	public void removeListener(PGIPListener listener) {
		fPGIPListeners.remove(listener);
	}
	
	private static LinkedList allSessionManagerListeners = new LinkedList();

	/** this will add the given listener to all current session managers (actually to their proverState objects if not null),
	 *  and keep a record of it so that it is automatically added to all new created session managers as well
	 *  (useful mainly for Views which might be created before or after the session manager)
	 */ 
	public static void addAllSessionManagerListener(PGIPListener l) {
		SessionManager[] sms;
		synchronized (allSessionManagerListeners) {
		  sms = ProofGeneralPlugin.getDefault().getSessionManagers();
		  allSessionManagerListeners.add(l);
		}
		for(int i=0; i<sms.length; i++) {
			SessionManager sm = sms[i];
			if (sm != null) {
				sm.addListener(l);  //the views added to the proverState instead, odd.
//				if (sm.proverState!=null) {
//					sm.proverState.addListener(l);
//				} else {
//					//shouldn't happen...
//					System.err.println("proverState is null on "+sm+"; adding to SessionManager instead.");
//					sm.addListener(l);
//				}
			} 
		}
	}
	/** this will stop automatically adding the listener to newly created session managers */
	public static void removeAllSessionManagerListener(PGIPListener l) {
		synchronized (allSessionManagerListeners) {
		  allSessionManagerListeners.remove(l);
		}		
	}
	
	List fPGIPListeners = new ArrayList();
	
	//i've changed firePGIPEvent to launch all events in separate threads -AH
	//synchronized on a lock object, and staggered so that they only run once the previous messages have all been handled
	
	public MutableInteger firingSequence = new MutableInteger(0);
	public int firingQueueSequence = 0;
	
	/** waits for all fired events to be dispensed */
	public void waitForProver(long ms) throws InterruptedException {
		synchronized (firingSequence) {
			while (firingSequence.get()<firingQueueSequence) firingSequence.wait(ms);					
		}
	}
//	/** waits for all fired events to be dispensed, queue to empty, and notification;
//	 *  on success, gives a lock to this thread, 
//	 *  which is cleared when the thread sends an event (or which the caller can clear) 
//	 * @param ms time to wait in ms, 0 doesn't wait, -1 waits indefinitely
//	 * @throws InterruptedException if interrupt() is called on the SessionManager
//	 * @return true if we got the prover, false if the time limit expired
//	 */
//  public boolean waitForProver(long ms) throws InterruptedException {			
//		synchronized (firingSequence) {
//			if (isClear() && hasProverThread==null) {
//				hasProverThread = Thread.currentThread();
//				return true;
//			}
//			if (ms==0) return false;
//			waitingThreads.add(Thread.currentThread());
//			try {
//			  while (!isClear()) firingSequence.wait((ms>0 ? ms : 0));
//			} finally {
//				waitingThreads.remove(Thread.currentThread());
//			}
//			if (isClear()) return true;
//		}
//		return false;
//	}
//  public void releaseProverLock() {
//  	hasProverThread = null;
//  	synchronized (firingSequence) {
//  		firingSequence.notify();
//  	}
//  }
//  //MutableObject proverLock = new MutableObject(null);
//  Thread hasProverThread = null;
//	ArrayList waitingThreads = new ArrayList();
	
	/** returns true if the queue is empty and all events have been dispensed */
	public boolean isEmptyQueueAndEvents() {
		return (commandQueue.isEmpty() && (firingSequence.get()==firingQueueSequence));
	}
	
	public boolean isEmptyQueue() {
		return commandQueue.isEmpty();
	}
	
	//public static final ThreadPool isabelleThreadPool = new ThreadPool("isabelle events pool");

	ArrayList activeFiredEvents = new ArrayList();
	
	/** a class to run event notifications in separate threads, synchronized on a lock object */
	private static class FirePGIPEventThread extends RunnableWithParams {
		MutableInteger firingSequence;
		int mySequenceNumber;
		PGIPListener listener;
		PGIPEvent event;
		SessionManager sm;
		public FirePGIPEventThread(MutableInteger firingSequence, int mySequenceNumber, PGIPListener listener,
				PGIPEvent event, SessionManager sm) {
			super(null, "FireEvent");
			this.firingSequence = firingSequence;
			this.mySequenceNumber = mySequenceNumber;
			this.listener = listener;
			this.event = event;
			this.sm = sm;
		}
		//		public ThreadPool getThreadPool() {
		//			return isabelleThreadPool;
		//		}
		Thread myThread = null;
		boolean localInterrupt = false;
		/** interrupts the thread where this task is running (if it is still running or still waiting for its sequence number);
		 *  returns whether we were able to interrupt something without error */
		public boolean interruptTask() {
			try {
				if (myThread!=null) synchronized (myThread) {
					localInterrupt = true;
					myThread.interrupt();
				}
				return true;
			} catch (Exception e) {
				localInterrupt = false;  //if we got an error
			}
			return false;
		}
		public void run() {
			try {
				if (firingSequence==null) {
					System.err.println("event "+this+" can't run with null sequence");
					return;
				}
				myThread = Thread.currentThread();				
				synchronized (firingSequence) {
					while (firingSequence.get()<mySequenceNumber) firingSequence.wait();					
					sm.activeFiredEvents.add(this);
				}
				if (ProofGeneralPlugin.LOG_EVENTS_RUNNING) System.out.println("Event ["+mySequenceNumber+"] sending to "+listener);
				//System.out.println("EVENT "+mySequenceNumber+": "+event+" to "+listener);//.getClass().toString());
				listener.pgipEvent(event);
				if (ProofGeneralPlugin.LOG_EVENTS_RUNNING) System.out.println("Event ["+mySequenceNumber+"] done from "+listener);
			} catch (InterruptedException e) {
				if (ProofGeneralPlugin.LOG_INTERRUPT_ACTIONS || ProofGeneralPlugin.LOG_EVENTS_RUNNING) System.out.println("event was interrupted: ["+mySequenceNumber+"] "+event);
				if (localInterrupt) {
					//clear the interrupt flag if this task was interrupted
					//(but not if the pool was interrupted)
					Thread.interrupted();
					localInterrupt = false;
				}
			} catch (Throwable e) {
				//we ignore these
				System.err.println("event firing error: "+event);
				e.printStackTrace();
			} finally {
				myThread = null;				
				synchronized (firingSequence) {
					sm.activeFiredEvents.remove(this);
					firingSequence.inc();
					firingSequence.notifyAll();
					if ((!(event instanceof InternalEvent.ProverClear)) && sm.isEmptyQueueAndEvents() && !sm.isOwned() &&
							!sm.startUpBumpfFlag &&
							!sm.tpOutputGobbler.bytesAvailable()) {
						sm.firePGIPEvent(new InternalEvent.ProverClear(sm, "just discharged last PGIPEvent"));
					}
				}				
			}
		}
	}
	
	/**
	 * Sends a PGIP event (containing the incoming pgip message)
	 * to all registered listeners.
	 */
	Object firingLock = new Object();
	public void firePGIPEvent(PGIPEvent event) {
		assert event!=null : "firePGIPEvent was given a null event";		
		if (logging) {			
			messageHistory.push(event);
		}
		
		//		if (ProofGeneralPlugin.debug()) {
		//			try {
		//				System.out.println(event.parseTree.asXML());
		//			} catch (Exception ex) {
		//				ex.printStackTrace();
		//			}
		//		}
		
		if (ProofGeneralPlugin.LOG_EVENTS_FIRING)
			System.out.println("firing event "+firingQueueSequence+": "+event);
		synchronized (firingLock) {  //needs to be synchronized against other invocations of this method (   
			if (privateListener != null) { // only send this to one listener
				new FirePGIPEventThread(firingSequence, firingQueueSequence++, privateListener, event, this).start();
			} else if (fPGIPListeners != null && fPGIPListeners.size() > 0) {
				//copy the listeners in case an event handler modifies it (guessing)  -AH
				Iterator e= new ArrayList(fPGIPListeners).iterator();
				int fQSconst = firingQueueSequence;
				while (e.hasNext()) {
					new FirePGIPEventThread(firingSequence, fQSconst, ((PGIPListener)e.next()), event, this).start();
					firingQueueSequence++;
				}
			}
			//also send to updater
		new FirePGIPEventThread(firingSequence, firingQueueSequence++, qUpdater, event, this).start();
		}
	}
	
	/**
	 * Block until the prover is ready, for a maximum of MAX millisecs.
	 * Uses setTimeout, which will fire an error  if it doesn't get a response.
	 * MAX must be used, since this method might be blocking the display thread
	 *  - it will default to the preference time out or 20secs if passed 0 or -1.
	 * TODO: I don't think this works properly,a lthough I can't see why not.
	 */
	/*public void wait4Ready(int MAX) {
	 if (MAX<1) {
	 MAX = ProofGeneralPlugin.getIntegerPref(Constants.PREF_TIME_OUT);
	 if (MAX<1) MAX = 20000;
	 }
	 if (!proverState.isBusy()) return;
	 boolean bg = backgroundThread;
	 backgroundThread=true; // so that any messages can get through the block we're about to throw up
	 setTimeout(MAX,false);
	 while (proverState.isAlive() && proverState.isBusy() && timeOuter != null) {
	 // wait
	  }
	  backgroundThread = bg;
	  }*/
	
	Parser parser = null;
	/**
	 * Access to deep (lazy) parsing is provided via the session manager
	 */
	public Parser getParser() {
		if (parser==null) {
			if (ProofGeneralPlugin.getBooleanPref(Constants.PREF_ENABLE_SCRIPTING))
				parser = new MixedParser(this);
			else parser = new ExternalLazyParser(this);
		}
		return parser;
	}
	/**
	 * Set to true to stop output being sent via the display thread
	 * Note: this will cause a stream of errors from thos PGIPListeners that try to do things with the display,
	 * but these should not be a problem
	 */
	//TODO actually i think nothing should be done in the display thread
	boolean dontProcessOutputInDisplayThread = false;
	
	/**
	 * This should normally be null. Setting it to non-null means that PGIP events are
	 * *only* sent to this listener.
	 */
//this has now become a param on queue command, etc; because otherwise if the queue is long could become inconsistent -AH
	//TODO ideally we can do without the privateListener field, just pass it from the CommandQueued if necessary
	PGIPListener privateListener = null;   
	
	
	/**
	 * Determines whether or not to keep messages.
	 * Affects both messageHistory and CommandHistory.
	 * Note: WITHOUT THIS SET TO TRUE, UNDO WILL NOT WORK.
	 */
	boolean logging = true;

	/** called when a stream stops being functional -- usually signifies the prover has closed */
	public void noteStreamStopped() {
		//TODO handle socket closures
		if (socket!=null) return;
		if (process==null) return;  //already dead, who cares
		try { 
			int i = process.exitValue();
			//if we get here, we know it exitted (which is why the thread closed)
			synchronized (this) {
				if (process==null) return;  //already dead, who cares
				System.out.println("prover exitted unexpectedly with exit code "+i);
				firePGIPEvent(new PGIPShutdown(this, "prover exitted unexpectedly with exit code "+i, null));
				killQueue("prover died");
				proverState.setAlive(false);
				process = null;
			}				
		} catch (Exception e) {
			//it didn't actually stop... 
			//this try/catch is the only way to see if the process exitted
		}
	}
	
	// handle TP output in a seperate thread or things will hang
	class StreamGobbler extends Thread
	{
		BufferedReader reader;
		SessionManager parent;
		boolean notifyOnStop = false;			
		
		StreamGobbler(String name, BufferedReader reader, SessionManager parent, boolean notifyOnStop) {
			super("SteamGobbler-Thread-"+name);
			this.reader = reader;
			this.parent = parent;
			this.notifyOnStop = notifyOnStop;
		}
//		StreamGobbler(BufferedReader reader, SessionManager parent) {
//			this(reader, parent, false);
//		}
		
		public boolean bytesAvailable() {
			//TODO should set this up as non-blocking (ready blocks, dammit)
			return false;
//			try {
//				System.out.println("waiting");
//				System.out.println("the tp output stream is "+(reader.ready() ? "active" : "quiet"));
//				return reader.ready();
//			} catch (IOException e) {
//				return false;
//			}
		}
		
		public void run() {
			try {
				String line="";
				while ((line = reader.readLine()) != null) {
					if (ProofGeneralPlugin.LOG_PROVER_IO) System.out.println(General.makeDateString()+"  READ: "+
							line);
							//(line.length()>50 ? line.substring(0, 50)+"..." : line));
					parent.processOutput(line);
					//TODO can remove all uses of dontParseInDisplayThread
					//no need ever to run it in the display thread... probably a bad idea in fact for speed reasons
//					if (parent.dontProcessOutputInDisplayThread) {
//						parent.processOutput(line);
//					} else {
//						org.eclipse.swt.widgets.Display.getDefault().asyncExec( new switchThread(parent,line) );
//					}
				}	       
				reader.close();
				if (notifyOnStop)  //normally only the output stream does this, to sync messages
				  noteStreamStopped();
			} catch (Exception e) {
				if (!isInterrupted()) e.printStackTrace();
				try {
					reader.close();
				} catch (Exception e2) {/*ignore*/}
			}
		}
		
		
		public void interrupt() {
			super.interrupt();
			//this blocks, deadlocking with readLine above
			//try {reader.close();} catch (Exception e) {}
			//should close on destroy... but if it doesn't consider using AutomaticInputStream -AH
		}
	}
	
	class switchThread implements Runnable {
		SessionManager sm;
		String line;
		public switchThread(SessionManager sm, String line) {
			this.sm = sm;
			this.line = line;
		}
		public void run () {
			sm.processOutput(line);
		}
	}
	
	/**
	 * Used to do time outs. Sends an error message if actually run.
	 */
	class CheckDone extends TimerTask {
		SessionManager sm;
		boolean fatal;
		/**
		 * 
		 * @param sm
		 * @param fatal - if true, a timeout error will be interpreted as a dead process.
		 */
		public CheckDone(SessionManager sm,boolean fatal) {
			this.sm = sm;
			this.fatal = fatal;
		}
		public void run() {	          
			String line;
			timeOuter = null;
			if (fatal) {
				sm.stopSession(null);
				String msg = "The theorem prover timed out, and is now presumed dead."
					+"\nThis session has been closed.";
				ErrorUI.getDefault().signalError(new Exception(msg));
			}
			String msg;
			try {
				DocElement cmd = (DocElement) commandQueue.get(0);
				msg = TIMEOUT_ERROR_TEXT + ": "+ cmd.getText();
			} catch (Exception ex) {
				msg = TIMEOUT_ERROR_TEXT;
			}
			line = "<pgip><errorresponse>"+msg+"</errorresponse></pgip>";
			org.eclipse.swt.widgets.Display.getDefault().asyncExec( new switchThread(sm,line) );	                	                           
		}
	}
	
	public static class TimeOutError extends PGIPError {
		public TimeOutError(Object source, String pgipMessage) {
			super(source, pgipMessage);
		}
		public TimeOutError(Object source, Element content) {
			super(source, content);
		}
	}
	
	
	public void propertyChange(PropertyChangeEvent event) {
		String prop = event.getProperty(); 
		if (prop.equals(Constants.PREF_ENABLE_SCRIPTING)) {
			parser = null; // reset the parser
		}
	}
	
	public void addTalker(PGEventMaker listenee) {
		talkers.add(listenee);
	}
	public void removeTalker(PGEventMaker listenee) {
		talkers.remove(listenee);
	}

	// -------- ownership

	//@TODO these should probably generate events
	
	/** allow an object to take "ownership" of the prover;
	 *  this is not a "hard" control, in the sense others can still send and queue commands,
	 *  but it is synced, so there can be only one owner at a time
	 * <p/>
	 *  most prover uses should try to take this ownership first
	 *  (and not run if they cannot)
	 * <p/>
	 *  they MUST release this ownership when done, even if there is an error,
	 *  otherwise no one can take it (unless it is interrupted or closed).
	 * @return whether this object got ownership 
	 */
	public boolean tryGetProverOwnership(Object newOwner) {
		if (isOwned()) return false;
		synchronized (proverOwnerLock) {
			if (isOwned()) return false;
			proverOwner = newOwner;			
		}
		return true;
	}
	
	/** whether the query parameter is the current owner of the prover */
	public boolean hasOwnership(Object queryOwner) {
		return (proverOwner!=null && proverOwner==queryOwner);
	}
	
	/** lets an object release ownership of a prover;
	 *  
	 * @throws ProverOwnedBySomeoneElseException if someone else owns it
	 * 
	 * @param owner the object owning the prover, for error checking; 
	 * if null, then anyone can clear it 
	 * 
	 * @return returns true if we released it, false if no one owned it
	 */
	public boolean releaseOwnership(Object owner) {
		if (proverOwner==null) return false;
		if (proverOwner==owner || owner==null) {
			synchronized (proverOwnerLock) {
				//repeat checks in sync block; did checks first for speed
				if (proverOwner==null) return false;
				if (proverOwner==owner || owner==null) {
					proverOwner=null;			
					synchronized (firingSequence) {
						//synchronized just to make sure
						if (isEmptyQueueAndEvents() && proverState.isAlive()) {  //we know it isn't owned ... TODO this should be a separate event type
							firePGIPEvent(new InternalEvent.ProverClear(this, "just released ownership"));
						}
					}
					synchronized (commandQueue) {
						commandQueue.notifyAll();  //notify anyone waiting on the queue to check
					}
					return true;
				}
			}
		}
		throw new ProverOwnedBySomeoneElseException(proverOwner, owner);
  }
	
	public static class ProverOwnedBySomeoneElseException extends RuntimeException {
		public Object owner;
		public Object attemptedOwnerToClear;
		public ProverOwnedBySomeoneElseException(Object owner,
				Object attemptedOwnerToClear) {
			super("The prover is owned by "+owner+" but the parameter "+attemptedOwnerToClear+" was passed to release ownership");
			this.owner = owner;
			this.attemptedOwnerToClear = attemptedOwnerToClear;
		}
	}
	
	private Object proverOwnerLock = new Object();
	private Object proverOwner = null;

	/**
	 * @return whether someone has claimed ownership of the prover
	 */
	public boolean isOwned() {
		return (proverOwner!=null);
	}

	//------------ default session ------------------------------
	
	public static SessionManager dflt = null;
	
	/**
	 * a helper routine to get the session manager, esp in standalone contexts;
	 * reliance on this routine means you can only have one session manager.
	 * (but use of static sessionmanager values in actions causes this anyway.)
	 * it would be better to pass the sm around where possible.
	 */
	public static SessionManager getDefault() {
		return dflt;
	}
	
}
